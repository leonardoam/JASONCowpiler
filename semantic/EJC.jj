options{IGNORE_CASE = true;/*DEBUG_PARSER = true;*/}
/*options{DEBUG_PARSER = true;}*/

PARSER_BEGIN(EJC)
import java.io.*;
import tadsemantico.*;
import java.util.*;

public class EJC{
	public final static SymbolTable st = new SymbolTable();
	public static int array_counter = 0;
	public static int record_counter = 0;
	public static final int MAX_ID_LENGTH = 128;
	public static final int MAX_STR_LENGTH = 258;//2 a mais para as aspas
	public static final int MAX_NUM_SIZE = 9;
	public static boolean semantic_error = false;
	public static String input = null;
	public static ArrayList<String> code = new ArrayList<String>();
	public static Stack<Integer> labels = new Stack<Integer>();
	public static Stack<Integer> dmem = new Stack<Integer>();
	public static int stack_pointer = 0;
	
    public static void main(String[] args){
        try{
			if(args.length != 1){
				System.out.println("Modo de uso:\n\tjava EJC <arquivo_fonte>");
				System.exit(0);
			}
			
			EJC EJC = new EJC(new FileInputStream(args[0]));
			EJC.input = args[0];
            EJC.start();
				
			if(!semantic_error)
				System.out.println("Sucesso! Programa compilado sem erros.");
			else 
				System.out.println("Compilacao concluida com erros.");
        }catch (Throwable t) {
            System.out.println("Erro!\n" + t.getMessage());
			//t.printStackTrace();
        }
    }
}

PARSER_END(EJC)

SKIP : {
	 " "
	|  "\t"
	|  "\n"
	|  "\r"
	|  "\r\n"
	|  <"{" (~["{", "}"])* "}">
}

/*Operadores*/
TOKEN:
{
    <EOL: "\\n" | "\\r" | "\\r\\n" > |
    <PLUS: "+"> |
    <MINUS: "-"> |
    <DIV: "/"> |
    <MUL: "*"> |
	<OR: "\\"> |
	<AND: "&"> |
	<NOT: "~"> |
	<GT: ">"> |
	<LT: "<"> |
	<GTE: ">="> |
	<LTE: "<="> |
	<EQUAL: "="> |
	<DIFF: "!"> 
}


/*Separadores e Agrupadores*/
TOKEN:
{
  <LPAR: "(">
 | <RPAR: ")">
|	<SEMICOLON: ";">
|	<COMMA: ",">
//|	<QUOT: "\""> 
|	<LSQ_BRACK: "[">
|	<RSQ_BRACK: "]">
|	<DOT: "."> 
}

/*Palavras reservadas e funcoes nativas*/
TOKEN:
{
	<ARRAY: "array">
	| 	<BEGIN: "begin">
	| 	<CALL: "call">
	|	<DO: "do">
	|	<ELSE: "else">
	| 	<END: "end">
	|	<ENDIF: "endif">
	| 	<ENDUNTIL: "enduntil">
	| 	<ENDWHILE: "endwhile">
	| 	<FUNCTION: "function">
	| 	<IF: "if">
	| 	<INTEGER: "integer">
	| 	<PARAMETERS: "parameters">
	| 	<PROCEDURE: "procedure">
	| 	<PROGRAM: "program">
	| 	<READ: "read">
	| 	<REAL: "real">
	| 	<RECORD: "record">
	| 	<RETURN: "return">
	| 	<RETURNS: "returns">
	| 	<SET: "set">
	| 	<STRING: "string">
	| 	<THEN: "then">
	| 	<TYPES: "types">
	| 	<UNTIL: "until">
	| 	<VAR: "var">
	| 	<VARIABLES: "variables">
	|	<WHILE: "while">
	| 	<WRITE: "write">
}

/*Numeros, palavras e identificadores*/
TOKEN:
{
	<#DIGIT: ["0"-"9"] > |
	<#LETTER: "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p"| "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A"| "B"| "C"| "D"| "E"| "F"| "G"| "H"| "I"| "J"| "K"| "L"| "M"| "N"| "O"| "P"| "Q"| "R"| "S"| "T"| "U"| "V"| "W"| "X"| "Y"| "Z"> |
	<#SYMBOL: " " | "!" | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | "\\" | ":" | ";" | "<" | "=" | ">"  | "[" | "]" | "^" | "{" | "|" | "}"> | 
		
	<#DIGITS: (<DIGIT>)*> |
	<#FORCE_DIGITS: <DIGIT>(<DIGIT>)*> |
	//<NUMERIC_LITERAL: <DIGITS> "." <FORCE_DIGITS> | <FORCE_DIGITS>"."<DIGITS>| <FORCE_DIGITS>> |
	<FLOAT: <DIGITS> "." <FORCE_DIGITS> | <FORCE_DIGITS>"."<DIGITS>> 
	//Java code
	{ 
		String[] strs = image.toString().split("\\.");
		
		if(strs[0].length() > EJC.MAX_NUM_SIZE || strs[1].length() > EJC.MAX_NUM_SIZE){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de digitos excedido.");
		}
	}|
	<INT: <FORCE_DIGITS>> 
	//Java code
	{ 
		String str = image.toString();
		if(str.length() > EJC.MAX_NUM_SIZE){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de digitos excedido.");
		}
	}|
	
	<#CHARACTER: <LETTER> | <DIGIT>> |
	<IDENTIFIER: <LETTER>(<CHARACTER>)*> 
	//Java code
	{ 
		str = image.toString();
		if(str.length() > EJC.MAX_ID_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tTamanho maximo para identificador excedido.");
		}
	}|
	
	<#ANY_CHARACTER: <LETTER> | <DIGIT> | <SYMBOL>> |
	<STRING_LITERAL: "\""(<ANY_CHARACTER>)*"\"">
	//Java code
	{ 
		str = image.toString();
		if(str.length() > EJC.MAX_STR_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de caracteres excedido.");
		}
	}
}

void finish_code():
{}
{
	//Java code
	{
		try{
			String[] strs = input.split("\\.");
			String fileName = strs[0];
			File output = new File(fileName+".mep");
			PrintWriter writer = new PrintWriter(output);
			//System.out.println("code.size: "+code.size());
			for(int i = 0; i < code.size(); i++){
				//System.out.println(i+".\t"+code.get(i));
				writer.println(code.get(i));
			}
			writer.close();
		}catch(Exception e){
			System.out.println("Falha ao gerar arquivo-objeto.\n\t"+e.getMessage());
			//e.printStackTrace();
		}
	}
}

void start():
{}
{
	//Java code
	{
		add_code("INPP", null, null);
	}
	Program()
	//Java code
	{
		add_code("DMEM", ""+dmem.pop(), null);
		add_code("PARA", null, null);
		add_code("FIM", null, null);
		finish_code();
	}
	
}

//add a line to the code vector according to the parameters
void add_code(String command, String param1, String param2):
{}
{
	//Java code
	{
		String code_line = "NADA";
		if(command != null)
			code_line = command;
		if(param1 != null)
			code_line += " "+param1;
		if(param2 != null)
			code_line += ","+param2;
			
		code.add(code_line);
	}
}

//add the label to the last line that had it undefined (the label is the last instruction)
void add_label():
{}
{
	//Java code
	{
		int i = labels.pop();
		code.set(i, code.get(i)+" "+(code.size()-1));
	}
}

//<Program> = <Header> <DeclSec> <Block>"."
void Program():
{Token t;}
{
	Header() DeclSec() Block()t=<DOT>
	//Java code
	{
		st.removeLevel();
	}
}

//<Header> = “program” “identifier” “;”
void Header():
{}
{
	<PROGRAM> <IDENTIFIER> <SEMICOLON>
}

//<Block> = “begin” <Statements> “end”
void Block():
{}
{
	//Java code
	{
		//add a NADA, this is the point where the main starts
		add_code("NADA", null, null);
		
		//does the backpatching to set the label
		add_label();
	}
	<BEGIN> Statements() <END>
}

//<DeclSec> = <TypeDeclSec> <VarDeclSec> <SubprogramDecls> 
void DeclSec():
{}
{
	TypeDeclSec() VarDeclSec() SubProgramDecls()
}

//<TypeDeclSec> = [“types” <TypeDecls>]
void TypeDeclSec():
{}
{
	(<TYPES> TypeDecls())?
}

//<TypeDecls> = <TypeDecl> {<TypeDecl>}
void TypeDecls():
{}
{
	TypeDecl()(TypeDecl())*
}

//<TypeDecl> = “identifier” <TypeSpecification>
void TypeDecl():
{
	Token t;
	Boolean correctSpecification;
}
{
	t = <IDENTIFIER>
	correctSpecification = TypeSpecification(t)
	//Java code
	{
		if(!correctSpecification || t.image.toString().length() > MAX_ID_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao do tipo "+t.image.toString()+".");
		}
	}
}

//<TypeSpecification> = <ArraySpecification> | <RecordSpecification>
boolean TypeSpecification(Token typeToken):
{
	Boolean isCorrect;
}
{
	isCorrect = ArraySpecification(typeToken) {return isCorrect;} //Java code
	| isCorrect = RecordSpecification(typeToken) {return isCorrect;} //Java code
}

//<ArraySpecification> = “array” <DataType> “[” <NumericLiteral> ”]” ";"
boolean ArraySpecification(Token typeToken):
{
	Token t;
	Boolean isCorrect;
}
{
	<ARRAY> t = DataType() 
	//Java code
	{
            String arrayName = "ARRAY"+array_counter;    
			st.addSymbol(arrayName, "ARRAY");
			Symbol s = st.search(t.image.toString());
			if(s == null || (!s.getTypeName().equals("TYPE") && !s.getTypeName().equals("REAL") && !s.getTypeName().equals("STRING") && !s.getTypeName().equals("INTEGER"))){
				//System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+t.image.toString()+" nao declarado.");
				isCorrect = false;
			}else{ 
				st.search(arrayName).getType().set("ELEMTYPE", s);
				isCorrect = true;
			}
            array_counter++;
		
	}
	<LSQ_BRACK> t = <INT> <RSQ_BRACK><SEMICOLON>
	//Java code
	{       //only if the array exists (check the code above!)
		int size = 0;
		try{
			size = Integer.parseInt(t.image.toString());
		}catch(Exception e){
			isCorrect = false;
		}
		st.search(arrayName).getType().set("size", size);
		boolean result = st.isSet(typeToken.image.toString());
		if(isCorrect && result){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+typeToken.beginLine+", coluna "+typeToken.beginColumn+".\n\tTipo "+typeToken.image.toString()+" ja foi declarado nesse contexto.");
		}else if(t.image.toString().length() > MAX_NUM_SIZE){
			isCorrect = false;
		}else if(isCorrect && typeToken.image.toString().length() <= MAX_ID_LENGTH){
			st.addSymbol(typeToken.image.toString(), "TYPE");
			st.search(typeToken.image.toString()).getType().set("ELEMTYPE", st.search(arrayName));
		}
		
		return isCorrect;
	}
}


//<RecordSpecification> = “record” <VarDecls> “end” “;”
boolean RecordSpecification(Token typeToken):
{
	Boolean isCorrect;
}
{
	<RECORD> 
	//Java code
	{
			String typeName = typeToken.image.toString();
            String recordName = "RECORD"+record_counter;    
			st.addSymbol(recordName, "RECORD");
	}
	isCorrect = VarDecls(true) <END><SEMICOLON>
	//Java code
	{
			record_counter++;
			boolean result = st.isSet(typeName);
			if(isCorrect && result){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+typeToken.beginLine+", coluna "+typeToken.beginColumn+".\n\tTipo "+typeToken.image.toString()+" ja foi declarado nesse contexto.");
			}else if(isCorrect && typeName.length() <= MAX_ID_LENGTH){
				st.addSymbol(typeName, "TYPE");
				st.search(typeName).getType().set("ELEMTYPE", st.search(recordName));
			}
		return isCorrect;
	}
}

//<VarDeclSec> = [“variables” <VarDecls>]
void VarDeclSec():
{}
{
	//Java code
	{
		//when entering VarDeclSec can always set the current level stack pointer to 0
		stack_pointer = 0;
	}
	(<VARIABLES> 
		//Java code
		{
			EJC.dmem.push(0);
		}
		VarDecls(false))?
}

//<VarDecls> = <VarDecl> {<VarDecl>}
boolean VarDecls(boolean comingFromRecordSpec):
{
	Boolean isCorrect = true;
	Boolean temp = false;
}
{
	temp = VarDecl(comingFromRecordSpec)
	//Java code
	{isCorrect = isCorrect && temp;}
	(
		temp = VarDecl(comingFromRecordSpec)
		//Java code
		{isCorrect = isCorrect && temp;}
	
	)*
	
	//Java code
	{return isCorrect;}
}

//<VarDecl> = <DataType> <IdList> “;”
boolean VarDecl(boolean comingFromRecordSpec):
{
	Token t;
	Boolean isCorrect;
}
{
	t = DataType() 
	isCorrect = IdList(t, comingFromRecordSpec) <SEMICOLON>
	//Java code
	{
		return isCorrect;
	}
}

//<DataType> = “real” | “integer” | <Identifier> | <String>
Token DataType():
{
	Token t;
}
{
	(t = <REAL> | t = <INTEGER> | 
	t = <IDENTIFIER> 
	//Java code
	{
		Symbol dt = st.search(t.image.toString());
		if(dt == null || (dt != null && !dt.getTypeName().equals("TYPE"))){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+t.image.toString()+" nao esta declarado.");
		}
	}
	| t = <STRING>)
	{return t;}
}

boolean addRecordField(Token datatype, Token identifier, boolean comingFromRecordSpec):
{
	Boolean isCorrect = true;
}
{	//Java code
	{
		if(comingFromRecordSpec){
			if(st.search(datatype.image.toString()) != null){//certifica-se que tipo eh valido, mas nao precisa imprimir nada caso nao seja
				boolean result = st.search("RECORD"+record_counter).getType().set(identifier.image.toString(), st.search(datatype.image.toString()));
				if(!result){
					EJC.semantic_error = true;
					System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tCampo "+identifier.image.toString()+" duplicado.");
					isCorrect = false;
				}			
			}else{
				isCorrect = false;
			}
		}else if(st.isSet(identifier.image.toString())){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tIdentificador "+identifier.image.toString()+" duplicado.");
		}else if(identifier.image.toString().length() > MAX_ID_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tErro na declaracao de "+identifier.image.toString()+".");
		}else{
			st.addSymbol(identifier.image.toString(), "VARIABLE");
			st.search(identifier.image.toString()).getType().set("ELEMTYPE", st.search(datatype.image.toString()));
			
			//allocate memory variables
			//System.out.println("nbytes: "+st.search(identifier.image.toString()).getType().get("_NBYTES_"));
			int nbytes = (Integer) st.search(identifier.image.toString()).getType().get("_NBYTES_");
			st.search(identifier.image.toString()).getType().set("_ADDRESS_", st.getCurrentLevel()+","+stack_pointer);
			//System.out.println(identifier.image.toString()+": "+st.search(identifier.image.toString()).getTypeName());
			add_code("AMEM", ""+nbytes, null);
			int idmem = dmem.size()-1;
			dmem.set(idmem,dmem.get(idmem)+nbytes);
			stack_pointer += nbytes;
		}
		return isCorrect;
	}
}

//<IdList> = <Identifier> {“,” <Identifier>}
boolean IdList(Token datatype, boolean comingFromRecordSpec):
{
	Token t;
	Boolean isCorrect = true;
	Boolean temp = false;
}
{
	t = <IDENTIFIER>
	//Java code
	{
		temp = addRecordField(datatype, t, comingFromRecordSpec);
		isCorrect = isCorrect && temp;
	}
	(
		<COMMA>
		t = <IDENTIFIER>
		//Java code
		{
			temp = addRecordField(datatype, t, comingFromRecordSpec);
			isCorrect = isCorrect && temp;
		}
	)*
	//Java code
	{return isCorrect;}
}

//<SubProgramDecls> = {<SubProgramDecl>}
void SubProgramDecls():
{}
{
	//Java code
	{
		//go to main procedure, it's going to be backpathed
		add_code("DSVS", null, null);		
		labels.push(code.size()-1);
	}
	(SubProgramDecl())*
}

//<SubProgramDecl> = <ProcDecl> | <FunctionDecl>
void SubProgramDecl():
{}
{
	(ProcDecl() | FunctionDecl())
	//Java code
	{
		st.removeLevel();
	}
}

//<ProcDecl> = <ProcHeader> <SubProgramDeclSec> <Block> “;”
void ProcDecl():
{
	String procName;
}
{
	procName = ProcHeader() SubProgramDeclSec(procName) Block() <SEMICOLON>
	//Java code
	{
		Integer nparams = (Integer)st.search(procName).getType().get("NPARAMS");
		add_code("DMEM", ""+dmem.pop(), null);
		add_code("RTPR", ""+st.getCurrentLevel(), ""+nparams);
	}
}

//<ProcHeader> = “procedure” <Identifier> “;”
String ProcHeader():
{
	Token t;
}
{
	<PROCEDURE> t = <IDENTIFIER> <SEMICOLON>
	//Java code
	{
		String procName = t.image.toString();
		if(procName.length() > MAX_ID_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao do procedimento "+t.image.toString()+".");
		}else if(!st.addSymbol(procName, "PROCEDURE")){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tIdentificador "+t.image.toString()+" ja foi declarado nesse contexto.");
		}else{
			//set procedure's entry point
			Type proc = st.search(procName).getType();
			proc.set("ENTRY", code.size());
			add_code("NADA", null, null);
			add_code("ENPR", ""+(st.getCurrentLevel()+1), null);
		}
		st.addLevel();
		return procName;
	}
}

//<SubProgramDeclSec> = <ParamDeclSec> <DeclSec>
void SubProgramDeclSec(String subProgramName):
{ 
	int nparams = 0;
}
{
	nparams = ParamDeclSec(subProgramName)
	//Java code
	{
		st.search(st.getCurrentLevel()-1, subProgramName).getType().set("nparams", nparams);
	}
	DeclSec()
}

//<ParamDeclSec> = [“parameters” <ParamDecls>]
int ParamDeclSec(String subprogramName):
{
	int nparams = 0;
}
{
	(<PARAMETERS> nparams = ParamDecls(subprogramName))?
	//Java code
	{
		return nparams;
	}
}

//<ParamDecls> = {<ParamDecl>}
int ParamDecls(String subProgramName):
{
	int nparams = 0;
}
{
	(nparams = ParamDecl(nparams, subProgramName))*
	//Java code
	{
		//set parameters' addresses
		if(nparams > 0){
			Type subprogram = st.search(subProgramName).getType();
			ArrayList<Symbol> params = (ArrayList<Symbol>) subprogram.get("PARAMS");
			
			for(int i = 0; i < params.size(); i++){
				params.get(i).getType().set("_ADDRESS_", ""+st.getCurrentLevel()+","+(i-2-params.size()));
			}
		}
		return nparams;
	}
}

//<ParamDecl> =["var"] <DataType> <Identifier> ";"
int ParamDecl(int nparams, String subprogramName):
{
	Token datatype;
	Token identifier;
	String tClass = "VALUE";
}
{
	(
		<VAR>
		//Java code
		{
				tClass = "REFERENCE";
		}
	)? 
	datatype = DataType() identifier = <IDENTIFIER> <SEMICOLON>
	//Java code
	{
		if(identifier.image.toString().length() > MAX_ID_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tErro na declaracao do parametro "+identifier.image.toString()+".");
		}else if(!st.addSymbol(identifier.image.toString(), "PARAM")){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tIdentificador "+identifier.image.toString()+" ja foi declarado nesse contexto.");
		}else{
			Symbol param = st.search(identifier.image.toString());
			Type t = param.getType();
			t.set("ELEMTYPE", st.search(datatype.image.toString()));
			t.set("TCLASS", tClass);
			Symbol subprogram = st.search(subprogramName);
			if(subprogram != null && subprogram.getType() != null){
				subprogram.getType().set("PARAM", param);
}
		}
		return nparams+1;
	}
}

//<FunctionDecl> = <FunctionHeader> <SubProgramDeclSec> <FunctionBlock> “;”
void FunctionDecl():
{
	String[] funcData;
}
{
	funcData = FunctionHeader() SubProgramDeclSec(funcData[0]) FunctionBlock(funcData[0], funcData[1]) <SEMICOLON>
}

//<FunctionHeader> = “function” <Identifier> “returns” <DataType>;
String[] FunctionHeader():
{
	Token t;
	Token returnType;
	String[] r = new String[2];
}
{
	<FUNCTION> t = <IDENTIFIER> <RETURNS> returnType = DataType() <SEMICOLON>
	//Java code
	{
		String funcName = t.image.toString();
		if(funcName.length() > MAX_ID_LENGTH){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao da funcao "+t.image.toString()+".");	
		}else if(!st.addSymbol(funcName, "FUNCTION")){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tIdentificador "+t.image.toString()+" ja foi declarado nesse contexto.");
		}else{
			st.search(funcName).getType().set("RTYPE", st.search(returnType.image.toString()));
			
			//set function's entry point
			Type func = st.search(funcName).getType();
			func.set("ENTRY", code.size());
			add_code("NADA", null, null);
			add_code("ENPR", ""+(st.getCurrentLevel()+1), null);
		}
		st.addLevel();
	r[0] = funcName; r[1] = returnType.image.toString().toUpperCase();
		return r;
	}
}

//modificado pra resolver ambiguidade
//<FunctionBlock> = “begin” <SpecialStatements> “end”
void FunctionBlock(String name, String returnType):
{}
{
	//Java code
	{
		//add a NADA, this is the point where the main starts
		add_code("NADA", null, null);
		
		//does the backpatching to set the label
		add_label();
	}
	<BEGIN> SpecialStatements(name, returnType) <END>
}

//<Statements> = <Statement> { “;”<Statement>}
void Statements():
{}
{
	Statement()(<SEMICOLON>Statement())*
}

//criado para resolver a ambiguidade com ReturnStatement
//<SpecialStatements> = <Statement>“;”{<Statement>“;”}<ReturnStatement>
void SpecialStatements(String name, String returnType):
{}
{
	(LOOKAHEAD(2)Statement()<SEMICOLON>)+ReturnStatement(name,returnType)
}


boolean printReadWriteError(String varType, Token t):
{}
{
	/*Java code*/
	{
		if(varType == null)
			varType = "_NULO_";
		if((!varType.equals("STRING") && !varType.equals("INTEGER") && !varType.equals("REAL"))){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para operacao de leitura ou escrita.\n\tEsperado: STRING, INTEGER ou REAL\n\tEncontrado: "+varType);
			return false;
		}
		return true;
	}
}

void printConditionError(String condType, Token t):
{}
{
	/*Java code*/
	{
		if(condType == null)
			condType = "_NULO_";

		if(!condType.equals("INTEGER")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para a condicao.\n\tEsperado: INTEGER\n\tEncontrado: "+condType);
			EJC.semantic_error = true;
		}
	}
}

boolean checkStructuralCompatibilityError(String expected, String real):
{}
{
	//Java code
	{
		Symbol s1 = st.search(expected);
		Symbol s2 = st.search(real);
		if(s1 == null || s1.getType() == null || s2 == null || s2.getType() == null)//error if any is null
			return true;
		if(!s1.getTypeName().equals("TYPE") && !s2.getTypeName().equals("TYPE"))//if both are of basic type, return true if they are different and false otherwise
			return !s1.getId().equals(s2.getId());
		if(s1.getTypeName().equals("TYPE") && s2.getTypeName().equals("TYPE")){//if both are user-defined types
			Symbol elem1 = (Symbol)s1.getType().get("ELEMTYPE");
			Symbol elem2 = (Symbol)s2.getType().get("ELEMTYPE");
			
			if(!elem1.getTypeName().equals(elem2.getTypeName()))//error if one is ARRAY and other is RECORD
				return true;
				
			//if both are array and have the same size, recursion
			if(elem1.getTypeName().equals("ARRAY") && elem1.getType().get("SIZE").equals(elem2.getType().get("SIZE"))){
				return checkStructuralCompatibilityError(((Symbol)elem1.getType().get("ELEMTYPE")).getId(), ((Symbol)elem2.getType().get("ELEMTYPE")).getId());
			}
			//if both are record and have the same size, recursion

			if(elem1.getTypeName().equals("RECORD")){
				RecordType rec1 = (RecordType) elem1.getType();
				boolean error = false;
				for(String field : (Set<String>)rec1.get("_FIELDS_")){
					if(elem2.getType().get(field) == null)//if second record doesn't have a field that's in the first
						return true;
					String t1 = ((Symbol)rec1.get(field)).getId();//getting field's type name for record 1
					String t2 = ((Symbol)elem2.getType().get(field)).getId();//getting field's type name for record 2
					error = error || checkStructuralCompatibilityError(t1, t2);
				}
				
				return error;
			}else{
				return true;
			}
		}
			
		return true;//error if one is basic type and other is user type
	}
}

boolean checkCompatibilityError(String expected, String real):
{}
{
	//Java code
	{
		boolean error = false;
		
		if(expected == null)
			expected = "_NULO_";
		if(real == null)
			real = "_NULO_";
		
		if(!expected.equals(real)){
			if(expected.equals("INTEGER")){
				if(!real.equals("REAL"))
					error = true;
			}else if(expected.equals("REAL")){
				if(!real.equals("INTEGER"))
					error = true;
			}else{
				if(expected.equals("STRING") || real.equals("STRING"))
					error = true;
				else if(!expected.equals("_NULO_") && !real.equals("_NULO_"))
					error = checkStructuralCompatibilityError(expected, real);
			}
		}
		
		return error;
	}
}

boolean printSetError(String varType, String exprType, Token t):
{}
{
	//Java code
{
	boolean error = checkCompatibilityError(varType, exprType);
	
	if(error){
		EJC.semantic_error = true;
		System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+exprType+" nao pode ser convertido para tipo "+varType);
		return false;
	}
	return true;
}
}

//<Statement> = [“read” <Variable> 
	//| “set” <Variable> “=” <Expression> 
	//| “write” <Variable>
	//| “if” <Condition> “then” <Statements> <ElseClause>
	//| “while” <Condition> “do” <Statements>  “endwhile”
	//| “until” <Condition> "do" <Statements> “enduntil”
	//| “call” <IDENTIFIER> <ArgList> ]
void Statement():
{
	Token t;
	int nparams;
	Symbol o = null;
	String varType, exprType, condType; 
}
{
	(
		t = <READ> 
		/*Java code*/
		{
			add_code("LEIT", null, null);
		}
		varType = Variable(0, false, o, null, 0) 
		/*Java code*/
		{
			printReadWriteError(varType, t);
		}|
		
		//Java code
		{
			int varIndex = code.size();
		}
		t = <SET> varType = Variable(0, false, o, null, 0) <EQUAL> exprType = Expression(null, 0) 
		/*Java code*/
		{
			String var = code.get(varIndex);
			//System.out.println("setting var: "+var);
			for(int i = varIndex; i < code.size()-1; i++){
				code.set(i, code.get(i+1));
			}
			code.set(code.size()-1, var);
			printSetError(varType, exprType, t);
		} |
		
		t = <WRITE> varType = Variable(1, false, o, null, 0) 
		/*Java code*/
		{
			boolean correct = printReadWriteError(varType, t);
			
			if(correct){
				add_code("IMPR", null, null);
			}
		}|
		t = <IF> condType = Condition(null, 0) <THEN>
			//Java code
			{
				add_code("DSVF", null, null);		
				labels.push(code.size()-1);
			}
			Statements() 
			//Java code
			{
				add_code("DSVS", null, null);
				Integer aux = labels.pop();//else instruction
				labels.push(code.size()-1);//post-if instruction
				labels.push(aux);//else instruction
				
				//does the backpatching to set the label
				add_code("NADA", null, null);
				add_label();
			}
			ElseClause() 
			/*Java code*/
			{
				printConditionError(condType, t);
				//does the backpatching to set the label
				add_code("NADA", null, null);
				add_label();
			} |
		//Java code
		{
			add_code("NADA", null, null);
			aux = code.size()-1;
		}
		t = <WHILE> condType = Condition(null, 0) 
		//Java code
		{
			add_code("DSVF", null, null);		
			labels.push(code.size()-1);
		}
		<DO> Statements() 
		//Java code
		{
			add_code("DSVS", ""+aux, null);		
			add_code("NADA", null, null);
			add_label();
		}
		<ENDWHILE> {printConditionError(condType, t);} /*Java code*/|
		//Java code
		{
			add_code("NADA", null, null);
			aux = code.size()-1;
		}
		t = <UNTIL> condType = Condition(null, 0) 
		//Java code
		{
			add_code("NEGA", null, null);		
			add_code("DSVF", null, null);		
			labels.push(code.size()-1);
		}
		<DO> Statements() 
		//Java code
		{
			add_code("DSVS", ""+aux, null);		
			add_code("NADA", null, null);
			add_label();
		}
		<ENDUNTIL> {printConditionError(condType, t);} /*Java code*/|
		<CALL> t = <IDENTIFIER> nparams = ArgList(t)
		//Java code
		{
			Symbol s = st.search(t.image.toString());
			if(s == null){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tProcedimento "+t.image.toString()+" nao foi declarado.");
			}else if(!s.getTypeName().equals("PROCEDURE")){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao eh um procedimento.");
			}else if(s.getType().get("NPARAMS") == null || !s.getType().get("NPARAMS").equals(nparams)){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para o procedimento "+t.image.toString()+" eh diferente do esperado.");
			}else{
				add_code("CHPR", ""+(Integer)s.getType().get("ENTRY"), null);
			}
		}
	)?
}
	
//<ElseClause> = [“else” <Statements>] “endif” 
void ElseClause():
{}
{
	(<ELSE> Statements())? <ENDIF>
}

void printReturnError(String returned, String expected, Token t):
{}
{
	//Java code
	{
	boolean error = checkCompatibilityError(expected, returned);
	
	if(error){
		EJC.semantic_error = true;
		System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.endColumn+".\n\tTipo "+returned+" nao pode ser convertido para tipo "+expected);
	}
}

}

//tiramos o ; como parte da resolução da ambiguidade com statement
//<ReturnStatement> = “;” “return” “(” <Condition> “)”
void ReturnStatement(String name, String returnType):
{
	String returnedType;
	Token t;
}
{
	<RETURN>t =<LPAR>returnedType = Condition(null, 0)<RPAR>
	//Java code
	{	
		printReturnError(returnedType, returnType, t);	
			
		Integer nparams = (Integer)st.search(name).getType().get("NPARAMS");
		if(nparams != null){
			int ret = -nparams-3;
			add_code("ARMZ", ""+st.getCurrentLevel(), ""+ret);
			add_code("DMEM", ""+dmem.pop(), null);
			add_code("RTPR", ""+st.getCurrentLevel(), ""+nparams);
		}
	}
}

//<ArgList> = [“(” <Arguments> “)” ]
int ArgList(Token t):
{
	int nparams = 0;
}
{
	(<LPAR>nparams = Arguments(t)<RPAR>)?
	{
		return nparams;
	}
}

//usado para resolver ambiguidade entre variable e chamada de funcao
//<ArgListSpecial> = “(” <Arguments> “)” 
int ArgListSpecial(Token t):
{
	int nparams = 0;
}
{
	<LPAR>nparams = Arguments(t)<RPAR>
	//Java code
	{
		return nparams;
	}
}

void printParamError(Token t, int paramIndex, String type):
{}
{
	//Java code
	{
		Symbol subprogram = st.search(t.image.toString());
		if(subprogram != null && subprogram.getType() != null){
		ArrayList<Symbol> params = (ArrayList<Symbol>) subprogram.getType().get("PARAMS");
		if(params != null && paramIndex < params.size() && params.get(paramIndex).getType() != null){
			Type p = params.get(paramIndex).getType();	
			if(p.get("TCLASS").equals("REFERENCE")){
				if(p.get("ELEMTYPE") != null && !((Symbol)p.get("ELEMTYPE")).getId().equals(type)){
					EJC.semantic_error = true;
					System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tParametro "+(paramIndex+1)+" invalido.\n\tEsperado: "+((Symbol)p.get("ELEMTYPE")).getId()+"\n\tEncontrado: "+type);
				}
}else{
	if(p.get("ELEMTYPE") != null && checkCompatibilityError(((Symbol)p.get("ELEMTYPE")).getId(), type)){
		EJC.semantic_error = true;
		System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tParametro "+(paramIndex+1)+" invalido.\n\tTipo "+type+" nao pode ser convertido para tipo "+((Symbol)p.get("ELEMTYPE")).getId());
}
}
}
}
}
}

//<Arguments> = <Argument> {“,” <Argument>}
int Arguments(Token t):
{
	int nparams = 0;
	String type;
}
{
	type = Argument(nparams, t.image.toString())
	{printParamError(t, nparams, type); nparams++;}//Java code
	(
		<COMMA> type = Argument(nparams, t.image.toString()) { printParamError(t, nparams, type); nparams++;}//Java code
	)*
	//Java code
	{
		return nparams;
	}
}

//<Condition> = <CompoundCondition> {“\” <CompoundCondition>}
String Condition(String subProgramName, int paramIndex):
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = CompoundCondition(subProgramName, paramIndex) 
	(
		t = <OR> operand2 = CompoundCondition(subProgramName, paramIndex)
		
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;				
			}
			add_code("DISJ", null, null);
		}
	)*
	
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger)
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

//<CompoundCondition> =<SimpleCondition> {“&” <SimpleCondition>}
String CompoundCondition(String subProgramName, int paramIndex):
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = SimpleCondition(subProgramName, paramIndex) 
	(
		t = <AND> operand2 = SimpleCondition(subProgramName, paramIndex)
		
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
			add_code("CONJ", null, null);
		}
	)*
	
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger)
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

//<SimpleCondition> = <Expression> [<RelOp> <Expression>] 
String SimpleCondition(String subProgramName, int paramIndex):
{
	String operand1;
	String operand2 = null;
	Token t = null;
}
{
	operand1 = Expression(subProgramName, paramIndex)( t = RelOp() operand2 = Expression(subProgramName, paramIndex))?
	//Java code
	{
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t) 
					|| printArithmeticOrRelationalOperandError(operand2, t))
			return null;

		switch(t.image.toString()){
			case "<":
				add_code("CMME", null, null);
				break;
			case ">":
				add_code("CMMA", null, null);
				break;
			case "<=":
				add_code("CMEG", null, null);
				break;
			case ">=":
				add_code("CMAG", null, null);
				break;
			case "=":
				add_code("CMIG", null, null);
				break;
			case "!":
				add_code("CMDG", null, null);
				break;
		}
		
		/*if(!operand1.equals("INTEGER") || !operand2.equals("INTEGER"))
			return "REAL";
		else*/
		return "INTEGER";
	}
}

//<Expression> =  <Term> {<AddOp> <Term>} 
String Expression(String subProgramName, int paramIndex):
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = Term(subProgramName, paramIndex) 
	(
		t = AddOp() operand2 = Term(subProgramName, paramIndex)
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
			if(t.image.toString().equals("+"))
				add_code("SOMA", null, null);
			else
				add_code("SUBT", null, null);
		}
	)*
	
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger)
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

//<Term> =  <Unary> {<MultiOP> <Unary>}
String Term(String subProgramName, int paramIndex):
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = Unary(subProgramName, paramIndex) 
	(
		t = MultOp() operand2 = Unary(subProgramName, paramIndex)
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
			if(t.image.toString().equals("*"))
				add_code("MULT", null, null);
			else
				add_code("DIVI", null, null);
		}
	)*
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger && !t.image.toString().equals("/"))
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

boolean printArithmeticOrRelationalOperandError(String varType, Token t):
{}
{
	/*Java code*/
	{
		if(varType == null)
			varType = "_NULO_";
		if((!varType.equals("INTEGER") && !varType.equals("REAL"))){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para operador aritmetico.\n\tEsperado: INTEGER ou REAL\n\tEncontrado: "+varType);
			return true;
		}
		return false;
	}
}

//<Unary> = (“+” | ”-”) Unary | <Factor>
String Unary(String subProgramName, int paramIndex):
{
	Token t = null;
	String typeName = null;
}
{
	(
		{add_code("CRCT", "0", null);}//Java code
		(t = <PLUS>|t = <MINUS>) typeName = Unary(subProgramName, paramIndex) 
		//Java code
		{
			if(t.image.toString().equals("+"))
				add_code("SOMA", null, null);
			else
				add_code("SUBT", null, null);
		}
		|
		typeName = Factor(subProgramName, paramIndex)
	)
	//Java code
	{
		if(t != null)
			if(printArithmeticOrRelationalOperandError(typeName, t))
				return null;
		return typeName;
	}
}

/*<Unary> = {(“+” | ”-”)} <Factor>
String Unary():
{
	Token t = null;
	String typeName = null;
}
{
	(t = <PLUS>| t = <MINUS>)* typeName = Factor() 
	//Java code
	{
		if(t != null)
			if(printArithmeticOrRelationalOperandError(typeName, t))
				return null;
		return typeName;
	}
}*/

boolean printLogicOperandError(String varType, Token t):
{}
{
	/*Java code*/
	{
		if(varType == null)
			varType = "_NULO_";
		if(!varType.equals("INTEGER")){
			EJC.semantic_error = true;
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para operador logico.\n\tEsperado: INTEGER\n\tEncontrado: "+varType);
			return true;
		}
		return false;
	}
}

//tambem modificado para remover ambiguidade entre variable e chamada de funcao
//<Factor> = <Identifier> <ArgListSpecial> | <NumericLiteral> | <StringLiteral> | “~”<Factor> | “(” <Condition> “)” | <Variable>
String Factor(String subProgramName, int paramIndex):
{
	Token t;
	int nparams = 0;
	Symbol o = null;
	String typeName = null;
	Symbol type = null;
	Token aux;
}
{
	(
		LOOKAHEAD(2) t = <IDENTIFIER> {add_code("AMEM", "1", null);}/*Java code, allocating space for the return*/nparams = ArgListSpecial(t) 
		//Java code
		{
			Symbol s = st.search(t.image.toString());
			if(s == null){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tFuncao "+t.image.toString()+" nao foi declarada.");
			}else if(!s.getTypeName().equals("FUNCTION") && nparams > 0){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao eh uma funcao.");
			}else if(s.getTypeName().equals("FUNCTION") && !s.getType().get("NPARAMS").equals(nparams)){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
			}else{
				add_code("CHPR", ""+(Integer)s.getType().get("ENTRY"), null);
				
				type = (Symbol)s.getType().get("RTYPE");
				typeName = type.getId();
			}
		}
		|
		t = <FLOAT> {typeName = "REAL"; add_code("CRCT", t.image.toString(), null);}/*Java code*/|
		t = <INT>	{typeName = "INTEGER"; add_code("CRCT", t.image.toString(), null);}/*Java code*/|
		t = <STRING_LITERAL> {typeName = "STRING";add_code("CRCT", t.image.toString(), null);}/*Java code*/|
		aux = <NOT> typeName = Factor(subProgramName, paramIndex) 
		/*Java code*/
		{
			if(printLogicOperandError(typeName, aux))
				return null;
			
			add_code("NEGA", null, null);
		}
		
		|
		<LPAR>typeName = Condition(null, paramIndex) <RPAR> |
		typeName = Variable(1, false, o, subProgramName, paramIndex)
	)
	{return typeName;}
}

int[] parseAddress(String address):
{}
{
	//Java code
	{
		try{
			String[] str = address.split(",");
			int[] index = new int[2];
			index[0] = Integer.parseInt(str[0]);
			index[1] = Integer.parseInt(str[1]);
			
			return index;
		}catch(Exception e){
			return null;
		}
	}
}

//<Variable> = <Identifier> [“[” <Expression> “]”]{“.”<Variable>}
//op == 0 -> ARMZ ou ARMI
//op == 1 -> CRVL ou CRVI
String Variable(int op, boolean recursion, Symbol field, String subProgramName, int paramIndex):
{
	Token t;
	Symbol type = null;
	String typeName = null;
	boolean hasIndex;
}
{
	{hasIndex = false;}//Java code
	t = <IDENTIFIER> (<LSQ_BRACK>Expression(null, 0)<RSQ_BRACK>{hasIndex = true;}/*Java code*/)?
	//Java code
	{	
		if(!recursion){//trata identificador inicial
			Symbol s = st.search(t.image.toString());
			field = s;
			
			if(s == null || s.getType() == null){
				field = null;
			}else{
				field = (Symbol) s.getType().get("ELEMTYPE");//s eh do tipo Variable
				type = field;
			}

			while(field != null && (field.getTypeName().equals("TYPE") 
					|| (field.getTypeName().equals("ARRAY") && hasIndex))){
				field = (Symbol) field.getType().get("ELEMTYPE");
			}
			
			//System.out.println(s.getTypeName());
			if(s == null){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao foi declarado.");
			}else if(!s.getTypeName().equals("VARIABLE") && !s.getTypeName().equals("PARAM") && !s.getTypeName().equals("FUNCTION")){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao pode ser usado nesse contexto.\n\tEsperado:\n\tFuncao, parametro ou variavel.");
			}else if(s.getTypeName().equals("FUNCTION") && !s.getType().get("NPARAMS").equals(0)){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
			}else if(s.getTypeName().equals("VARIABLE") || s.getTypeName().equals("PARAM")){
				String address = (String)s.getType().get("_ADDRESS_");
				String[] i = address.split(",");
				if(i != null){ 
					if(subProgramName != null){
						Symbol subprogram = st.search(subProgramName);
						Symbol param = ((ArrayList<Symbol>) subprogram.getType().get("PARAMS")).get(paramIndex);
						if(param.getType().get("TCLASS").equals("REFERENCE") && 
							(!s.getTypeName().equals("PARAM") || !s.getType().get("TCLASS").equals("REFERENCE"))){
							add_code("CREN", i[0], i[1]);
						}else{
							add_code("CRVL", i[0], i[1]);
						}
					}else{
						if(s.getTypeName().equals("PARAM") && s.getType().get("TCLASS").equals("REFERENCE")){
							if(op == 0){
								add_code("ARMI", i[0], i[1]);
							}else{
								add_code("CRVI", i[0], i[1]);
							}
						}else{
							if(op == 0){
								add_code("ARMZ", i[0], i[1]);
							}else{
								add_code("CRVL", i[0], i[1]);
							}
						}
					}
				}
			}
		}else{//trata campos
			if(field == null){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tImpossivel acessar o campo "+t.image.toString()+" porque um ou mais campos anteriores nao foram declarados corretamente.");
			}else if(field.getTypeName().equals("ARRAY")){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tImpossivel acessar o campo "+t.image.toString()+" a partir de um array.");
			}else if(!field.getTypeName().equals("RECORD") || field.getType().get(t.image.toString()) == null){
				EJC.semantic_error = true;
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tCampo "+t.image.toString()+" nao foi declarado.");
				field = null;
			}else{
				field = (Symbol) field.getType().get(t.image.toString());
				type = field;
				while(field != null && (field.getTypeName().equals("TYPE") 
										|| (field.getTypeName().equals("ARRAY") && hasIndex))){
					field = (Symbol) field.getType().get("ELEMTYPE");
				}
			}
		}
	}
	
	(LOOKAHEAD(2)<DOT>typeName = Variable(op, true, field, subProgramName, paramIndex))*
	{
		if(typeName == null){//if it didn't go into a recursion
			if(type == null || type.getType() == null)
				typeName = "_NULO_";
			else{
				typeName = type.getTypeName();
				if(typeName.equals("TYPE") && hasIndex){
					type = (Symbol)type.getType().get("ELEMTYPE");
					typeName = type.getTypeName();
				}
				
				if(typeName.equals("FUNCTION")){
					add_code("AMEM", "1", null);//allocating space for the return value
					add_code("CHPR", ""+(Integer)type.getType().get("ENTRY"), null);
					
					type = ((Symbol)type.getType().get("RTYPE"));
				}else if(typeName.equals("ARRAY") && hasIndex){
					type = ((Symbol)type.getType().get("ELEMTYPE"));
				}
				else if(typeName.equals("VARIABLE")){
					type = ((Symbol)type.getType().get("ELEMTYPE"));
				}
				
				typeName = type.getId();
			}
			//System.out.println("line: "+t.beginLine+", tipo: "+typeName);			
		}
		return typeName;
	}
}

//<RelOp> = “=” | “!” | “>” | “<” | “<=” | “>=”
Token RelOp():
{
	Token t;
}
{
	(t = <EQUAL> | t = <DIFF> | LOOKAHEAD(2) t = <GTE> | LOOKAHEAD(2)t = <LTE> | t = <GT> | t = <LT>)
	
	{return t;}//Java code
}

//<AddOp> = “+” | “-”
Token AddOp():
{
	Token t;
}
{
	(t = <PLUS> | t = <MINUS>)
	{return t;}//Java code
}

//<MultOp> = “*” | “/”
Token MultOp():
{
	Token t;
}
{
	(t = <MUL> | t = <DIV>)
	{return t;}//Java code
}

//<Argument> = <Condition>
String Argument(int paramIndex, String subProgramName):
{String typeName;}
{
	typeName = Condition(subProgramName, paramIndex) {return typeName;}//Java code
}

