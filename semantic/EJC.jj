options{IGNORE_CASE = true;/*DEBUG_PARSER = true;*/}
/*options{DEBUG_PARSER = true;}*/

PARSER_BEGIN(EJC)
import java.io.*;
import tadsemantico.*;
import java.util.*;

public class EJC{
	public final static SymbolTable st = new SymbolTable();
	public static int array_counter = 0;
	public static int record_counter = 0;
	public static final int MAX_ID_LENGTH = 128;
	public static final int MAX_STR_LENGTH = 258;//2 a mais para as aspas
	public static final int MAX_NUM_SIZE = 9;
	
    public static void main(String[] args) throws ParseException, TokenMgrError{
        EJC EJC = new EJC(System.in);
        try{
            EJC.start();
            System.out.println("Sucesso!");
        }catch (Exception e) {
            //System.out.println("Erro!\n" + e.toString());
			e.printStackTrace();
        }
    }
}

PARSER_END(EJC)

SKIP : {
	 " "
	|  "\t"
	|  "\n"
	|  "\r"
	|  "\r\n"
	|  <"{" (~["{", "}"])* "}">
}

/*Operadores*/
TOKEN:
{
    <EOL: "\\n" | "\\r" | "\\r\\n" > |
    <PLUS: "+"> |
    <MINUS: "-"> |
    <DIV: "/"> |
    <MUL: "*"> |
	<OR: "\\"> |
	<AND: "&"> |
	<NOT: "~"> |
	<GT: ">"> |
	<LT: "<"> |
	<GTE: ">="> |
	<LTE: "<="> |
	<EQUAL: "="> |
	<DIFF: "!"> 
}


/*Separadores e Agrupadores*/
TOKEN:
{
  <LPAR: "(">
 | <RPAR: ")">
|	<SEMICOLON: ";">
|	<COMMA: ",">
//|	<QUOT: "\""> 
|	<LSQ_BRACK: "[">
|	<RSQ_BRACK: "]">
|	<DOT: "."> 
}

/*Palavras reservadas e funcoes nativas*/
TOKEN:
{
	<ARRAY: "array">
	| 	<BEGIN: "begin">
	| 	<CALL: "call">
	|	<DO: "do">
	|	<ELSE: "else">
	| 	<END: "end">
	|	<ENDIF: "endif">
	| 	<ENDUNTIL: "enduntil">
	| 	<ENDWHILE: "endwhile">
	| 	<FUNCTION: "function">
	| 	<IF: "if">
	| 	<INTEGER: "integer">
	| 	<PARAMETERS: "parameters">
	| 	<PROCEDURE: "procedure">
	| 	<PROGRAM: "program">
	| 	<READ: "read">
	| 	<REAL: "real">
	| 	<RECORD: "record">
	| 	<RETURN: "return">
	| 	<RETURNS: "returns">
	| 	<SET: "set">
	| 	<STRING: "string">
	| 	<THEN: "then">
	| 	<TYPES: "types">
	| 	<UNTIL: "until">
	| 	<VAR: "var">
	| 	<VARIABLES: "variables">
	|	<WHILE: "while">
	| 	<WRITE: "write">
}

/*Numeros, palavras e identificadores*/
TOKEN:
{
	<#DIGIT: ["0"-"9"] > |
	<#LETTER: "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p"| "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A"| "B"| "C"| "D"| "E"| "F"| "G"| "H"| "I"| "J"| "K"| "L"| "M"| "N"| "O"| "P"| "Q"| "R"| "S"| "T"| "U"| "V"| "W"| "X"| "Y"| "Z"> |
	<#SYMBOL: " " | "!" | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | "\\" | ":" | ";" | "<" | "=" | ">"  | "[" | "]" | "^" | "{" | "|" | "}"> | 
		
	<#DIGITS: (<DIGIT>)*> |
	<#FORCE_DIGITS: <DIGIT>(<DIGIT>)*> |
	//<NUMERIC_LITERAL: <DIGITS> "." <FORCE_DIGITS> | <FORCE_DIGITS>"."<DIGITS>| <FORCE_DIGITS>> |
	<FLOAT: <DIGITS> "." <FORCE_DIGITS> | <FORCE_DIGITS>"."<DIGITS>> 
	//Java code
	{ 
		String[] strs = image.toString().split("\\.");
		
		if(strs[0].length() > EJC.MAX_NUM_SIZE || strs[1].length() > EJC.MAX_NUM_SIZE){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de digitos excedido.");
		}
	}|
	<INT: <FORCE_DIGITS>> 
	//Java code
	{ 
		String str = image.toString();
		if(str.length() > EJC.MAX_NUM_SIZE){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de digitos excedido.");
		}
	}|
	
	<#CHARACTER: <LETTER> | <DIGIT>> |
	<IDENTIFIER: <LETTER>(<CHARACTER>)*> 
	//Java code
	{ 
		str = image.toString();
		if(str.length() > EJC.MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tTamanho maximo para identificador excedido.");
		}
	}|
	
	<#ANY_CHARACTER: <LETTER> | <DIGIT> | <SYMBOL>> |
	<STRING_LITERAL: "\""(<ANY_CHARACTER>)*"\"">
	//Java code
	{ 
		str = image.toString();
		if(str.length() > EJC.MAX_STR_LENGTH){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de caracteres excedido.");
		}
	}
}

void start():
{}
{
	Program()
}

//<Program> = <Header> <DeclSec> <Block>"."
void Program():
{Token t;}
{
	Header() DeclSec() Block()t=<DOT>
	//Java code
	{
		st.removeLevel();
	}
}

//<Header> = “program” “identifier” “;”
void Header():
{}
{
	<PROGRAM> <IDENTIFIER> <SEMICOLON>
}

//<Block> = “begin” <Statements> “end”
void Block():
{}
{
	<BEGIN> Statements() <END>
}

//<DeclSec> = <TypeDeclSec> <VarDeclSec> <SubprogramDecls> 
void DeclSec():
{}
{
	TypeDeclSec() VarDeclSec() SubProgramDecls()
}

//<TypeDeclSec> = [“types” <TypeDecls>]
void TypeDeclSec():
{}
{
	(<TYPES> TypeDecls())?
}

//<TypeDecls> = <TypeDecl> {<TypeDecl>}
void TypeDecls():
{}
{
	TypeDecl()(TypeDecl())*
}

//<TypeDecl> = “identifier” <TypeSpecification>
void TypeDecl():
{
	Token t;
	Boolean correctSpecification;
}
{
	t = <IDENTIFIER>
	correctSpecification = TypeSpecification(t)
	//Java code
	{
		if(!correctSpecification || t.image.toString().length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao do tipo "+t.image.toString()+".");
		}
	}
}

//<TypeSpecification> = <ArraySpecification> | <RecordSpecification>
boolean TypeSpecification(Token typeToken):
{
	Boolean isCorrect;
}
{
	isCorrect = ArraySpecification(typeToken) {return isCorrect;} //Java code
	| isCorrect = RecordSpecification(typeToken) {return isCorrect;} //Java code
}

//<ArraySpecification> = “array” <DataType> “[” <NumericLiteral> ”]” ";"
boolean ArraySpecification(Token typeToken):
{
	Token t;
	Boolean isCorrect;
}
{
	<ARRAY> t = DataType() 
	//Java code
	{
            String arrayName = "ARRAY"+array_counter;    
			st.addSymbol(arrayName, "ARRAY");
			Symbol s = st.search(t.image.toString());
			if(s == null || (!s.getTypeName().equals("TYPE") && !s.getTypeName().equals("REAL") && !s.getTypeName().equals("STRING") && !s.getTypeName().equals("INTEGER"))){
				//System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+t.image.toString()+" nao declarado.");
				isCorrect = false;
			}else{ 
				st.search(arrayName).getType().set("ELEMTYPE", s);
				isCorrect = true;
			}
            array_counter++;
		
	}
	<LSQ_BRACK> t = <INT> <RSQ_BRACK><SEMICOLON>
	//Java code
	{       //only if the array exists (check the code above!)
		int size = 0;
		try{
			size = Integer.parseInt(t.image.toString());
		}catch(Exception e){
			isCorrect = false;
		}
		st.search(arrayName).getType().set("size", size);
		boolean result = st.isSet(typeToken.image.toString());
		if(isCorrect && result){
			System.out.println("Erro semantico na linha "+typeToken.beginLine+", coluna "+typeToken.beginColumn+".\n\tTipo "+typeToken.image.toString()+" ja foi declarado nesse contexto.");
		}else if(t.image.toString().length() > MAX_NUM_SIZE){
			isCorrect = false;
		}else if(isCorrect && typeToken.image.toString().length() <= MAX_ID_LENGTH){
			st.addSymbol(typeToken.image.toString(), "TYPE");
			st.search(typeToken.image.toString()).getType().set("ELEMTYPE", st.search(arrayName));
		}
		
		return isCorrect;
	}
}


//<RecordSpecification> = “record” <VarDecls> “end” “;”
boolean RecordSpecification(Token typeToken):
{
	Boolean isCorrect;
}
{
	<RECORD> 
	//Java code
	{
			String typeName = typeToken.image.toString();
            String recordName = "RECORD"+record_counter;    
			st.addSymbol(recordName, "RECORD");
	}
	isCorrect = VarDecls(true) <END><SEMICOLON>
	//Java code
	{
			record_counter++;
			boolean result = st.isSet(typeName);
			if(isCorrect && result){
				System.out.println("Erro semantico na linha "+typeToken.beginLine+", coluna "+typeToken.beginColumn+".\n\tTipo "+typeToken.image.toString()+" ja foi declarado nesse contexto.");
			}else if(isCorrect && typeName.length() <= MAX_ID_LENGTH){
				st.addSymbol(typeName, "TYPE");
				st.search(typeName).getType().set("ELEMTYPE", st.search(recordName));
			}
		return isCorrect;
	}
}

//<VarDeclSec> = [“variables” <VarDecls>]
void VarDeclSec():
{}
{
	(<VARIABLES> VarDecls(false))?
}

//<VarDecls> = <VarDecl> {<VarDecl>}
boolean VarDecls(boolean comingFromRecordSpec):
{
	Boolean isCorrect = true;
	Boolean temp = false;
}
{
	temp = VarDecl(comingFromRecordSpec)
	//Java code
	{isCorrect = isCorrect && temp;}
	(
		temp = VarDecl(comingFromRecordSpec)
		//Java code
		{isCorrect = isCorrect && temp;}
	
	)*
	
	//Java code
	{return isCorrect;}
}

//<VarDecl> = <DataType> <IdList> “;”
boolean VarDecl(boolean comingFromRecordSpec):
{
	Token t;
	Boolean isCorrect;
}
{
	t = DataType() 
	isCorrect = IdList(t, comingFromRecordSpec) <SEMICOLON>
	//Java code
	{return isCorrect;}
}

//<DataType> = “real” | “integer” | <Identifier> | <String>
Token DataType():
{
	Token t;
}
{
	(t = <REAL> | t = <INTEGER> | 
	t = <IDENTIFIER> 
	//Java code
	{
		Symbol dt = st.search(t.image.toString());
		if(dt == null || (dt != null && !dt.getTypeName().equals("TYPE"))){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+t.image.toString()+" nao esta declarado.");
		}
	}
	| t = <STRING>)
	{return t;}
}

boolean addRecordField(Token datatype, Token identifier, boolean comingFromRecordSpec):
{
	Boolean isCorrect = true;
}
{	//Java code
	{
		if(comingFromRecordSpec){
			if(st.search(datatype.image.toString()) != null){//certifica-se que tipo eh valido, mas nao precisa imprimir nada caso nao seja
				boolean result = st.search("RECORD"+record_counter).getType().set(identifier.image.toString(), st.search(datatype.image.toString()));
				if(!result){
					System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tCampo "+identifier.image.toString()+" duplicado.");
					isCorrect = false;
				}			
			}else{
				isCorrect = false;
			}
		}else if(st.isSet(identifier.image.toString())){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tIdentificador "+identifier.image.toString()+" duplicado.");
		}else if(identifier.image.toString().length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tErro na declaracao de "+identifier.image.toString()+".");
		}else{
			st.addSymbol(identifier.image.toString(), "VARIABLE");
			st.search(identifier.image.toString()).getType().set("ELEMTYPE", st.search(datatype.image.toString()));
		}
		return isCorrect;
	}
}

//<IdList> = <Identifier> {“,” <Identifier>}
boolean IdList(Token datatype, boolean comingFromRecordSpec):
{
	Token t;
	Boolean isCorrect = true;
	Boolean temp = false;
}
{
	t = <IDENTIFIER>
	//Java code
	{
		temp = addRecordField(datatype, t, comingFromRecordSpec);
		isCorrect = isCorrect && temp;
	}
	(
		<COMMA>
		t = <IDENTIFIER>
		//Java code
		{
			temp = addRecordField(datatype, t, comingFromRecordSpec);
			isCorrect = isCorrect && temp;
		}
	)*
	//Java code
	{return isCorrect;}
}

//<SubProgramDecls> = {<SubProgramDecl>}
void SubProgramDecls():
{}
{
	(SubProgramDecl())*
}

//<SubProgramDecl> = <ProcDecl> | <FunctionDecl>
void SubProgramDecl():
{}
{
	(ProcDecl() | FunctionDecl())
	//Java code
	{
		st.removeLevel();
	}
}

//<ProcDecl> = <ProcHeader> <SubProgramDeclSec> <Block> “;”
void ProcDecl():
{
	String procName;
}
{
	procName = ProcHeader() SubProgramDeclSec(procName) Block() <SEMICOLON>
}

//<ProcHeader> = “procedure” <Identifier> “;”
String ProcHeader():
{
	Token t;
}
{
	<PROCEDURE> t = <IDENTIFIER> <SEMICOLON>
	//Java code
	{
		String procName = t.image.toString();
		if(procName.length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao do procedimento "+t.image.toString()+".");
		}else if(!st.addSymbol(procName, "PROCEDURE")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tIdentificador "+t.image.toString()+" ja foi declarado nesse contexto.");
		}
		st.addLevel();
		return procName;
	}
}

//<SubProgramDeclSec> = <ParamDeclSec> <DeclSec>
void SubProgramDeclSec(String subProgramName):
{ 
	int nparams = 0;
}
{
	nparams = ParamDeclSec(subProgramName)
	//Java code
	{
		st.search(st.getCurrentLevel()-1, subProgramName).getType().set("nparams", nparams);
	}
	DeclSec()
}

//<ParamDeclSec> = [“parameters” <ParamDecls>]
int ParamDeclSec(String subprogramName):
{
	int nparams = 0;
}
{
	(<PARAMETERS> nparams = ParamDecls(subprogramName))?
	//Java code
	{
		return nparams;
	}
}

//<ParamDecls> = {<ParamDecl>}
int ParamDecls(String subprogramName):
{
	int nparams = 0;
}
{
	(nparams = ParamDecl(nparams, subprogramName))*
	//Java code
	{
		return nparams;
	}
}

//<ParamDecl> =["var"] <DataType> <Identifier> ";"
int ParamDecl(int nparams, String subprogramName):
{
	Token datatype;
	Token identifier;
	String tClass = "VALUE";
}
{
	(
		<VAR>
		//Java code
		{
				tClass = "REFERENCE";
		}
	)? 
	datatype = DataType() identifier = <IDENTIFIER> <SEMICOLON>
	//Java code
	{
		if(identifier.image.toString().length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tErro na declaracao do parametro "+identifier.image.toString()+".");
		}else if(!st.addSymbol(identifier.image.toString(), "PARAM")){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tIdentificador "+identifier.image.toString()+" ja foi declarado nesse contexto.");
		}else{
			Symbol param = st.search(identifier.image.toString());
			Type t = param.getType();
			t.set("ELEMTYPE", st.search(datatype.image.toString()));
			t.set("TCLASS", tClass);
			Symbol subprogram = st.search(subprogramName);
			if(subprogram != null && subprogram.getType() != null){
				subprogram.getType().set("PARAM", param);
}
		}
		return nparams+1;
	}
}

//<FunctionDecl> = <FunctionHeader> <SubProgramDeclSec> <FunctionBlock> “;”
void FunctionDecl():
{
	String[] funcData;
}
{
	funcData = FunctionHeader() SubProgramDeclSec(funcData[0]) FunctionBlock(funcData[1]) <SEMICOLON>
}

//<FunctionHeader> = “function” <Identifier> “returns” <DataType>;
String[] FunctionHeader():
{
	Token t;
	Token returnType;
	String[] r = new String[2];
}
{
	<FUNCTION> t = <IDENTIFIER> <RETURNS> returnType = DataType() <SEMICOLON>
	//Java code
	{
		String funcName = t.image.toString();
		if(funcName.length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao da funcao "+t.image.toString()+".");	
		}else if(!st.addSymbol(funcName, "FUNCTION")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tIdentificador "+t.image.toString()+" ja foi declarado nesse contexto.");
		}else{
			st.search(funcName).getType().set("RTYPE", st.search(returnType.image.toString()));
		}
		st.addLevel();
	r[0] = funcName; r[1] = returnType.image.toString().toUpperCase();
		return r;
	}
}

//modificado pra resolver ambiguidade
//<FunctionBlock> = “begin” <SpecialStatements> “end”
void FunctionBlock(String returnType):
{}
{
	<BEGIN> SpecialStatements(returnType) <END>
}

//<Statements> = <Statement> { “;”<Statement>}
void Statements():
{}
{
	Statement()(<SEMICOLON>Statement())*
}

//criado para resolver a ambiguidade com ReturnStatement
//<SpecialStatements> = <Statement>“;”{<Statement>“;”}<ReturnStatement>
void SpecialStatements(String returnType):
{}
{
	(LOOKAHEAD(2)Statement()<SEMICOLON>)+ReturnStatement(returnType)
}


void printReadWriteError(String varType, Token t):
{}
{
	/*Java code*/
	{
		if(varType == null)
			varType = "_NULO_";
		if((!varType.equals("STRING") && !varType.equals("INTEGER") && !varType.equals("REAL")))
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para operacao de leitura ou escrita.\n\tEsperado: STRING, INTEGER ou REAL\n\tEncontrado: "+varType);
	}
}

void printConditionError(String condType, Token t):
{}
{
	/*Java code*/
	{
		if(condType == null)
			condType = "_NULO_";

		if(!condType.equals("INTEGER"))
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para a condicao.\n\tEsperado: INTEGER\n\tEncontrado: "+condType);
	}
}

boolean checkStructuralCompatibilityError(String expected, String real):
{}
{
	//Java code
	{
		Symbol s1 = st.search(expected);
		Symbol s2 = st.search(real);
		if(s1 == null || s1.getType() == null || s2 == null || s2.getType() == null)//error if any is null
			return true;
		if(!s1.getTypeName().equals("TYPE") && !s2.getTypeName().equals("TYPE"))//if both are of basic type, return true if they are different and false otherwise
			return !s1.getId().equals(s2.getId());
		if(s1.getTypeName().equals("TYPE") && s2.getTypeName().equals("TYPE")){//if both are user-defined types
			Symbol elem1 = (Symbol)s1.getType().get("ELEMTYPE");
			Symbol elem2 = (Symbol)s2.getType().get("ELEMTYPE");
			
			if(!elem1.getTypeName().equals(elem2.getTypeName()))//error if one is ARRAY and other is RECORD
				return true;
				
			//if both are array and have the same size, recursion
			if(elem1.getTypeName().equals("ARRAY") && elem1.getType().get("SIZE").equals(elem2.getType().get("SIZE"))){
				return checkStructuralCompatibilityError(((Symbol)elem1.getType().get("ELEMTYPE")).getId(), ((Symbol)elem2.getType().get("ELEMTYPE")).getId());
			}
			//if both are record and have the same size, recursion

			if(elem1.getTypeName().equals("RECORD")){
				RecordType rec1 = (RecordType) elem1.getType();
				boolean error = false;
				for(String field : (Set<String>)rec1.get("_FIELDS_")){
					if(elem2.getType().get(field) == null)//if second record doesn't have a field that's in the first
						return true;
					String t1 = ((Symbol)rec1.get(field)).getId();//getting field's type name for record 1
					String t2 = ((Symbol)elem2.getType().get(field)).getId();//getting field's type name for record 2
					error = error || checkStructuralCompatibilityError(t1, t2);
				}
				
				return error;
			}else{
				return true;
			}
		}
			
		return true;//error if one is basic type and other is user type
	}
}

boolean checkCompatibilityError(String expected, String real):
{}
{
	//Java code
	{
		boolean error = false;
		
		if(expected == null)
			expected = "_NULO_";
		if(real == null)
			real = "_NULO_";
		
		if(!expected.equals(real)){
			if(expected.equals("INTEGER")){
				if(!real.equals("REAL"))
					error = true;
			}else if(expected.equals("REAL")){
				if(!real.equals("INTEGER"))
					error = true;
			}else{
				if(expected.equals("STRING") || real.equals("STRING"))
					error = true;
				else if(!expected.equals("_NULO_") && !real.equals("_NULO_"))
					error = checkStructuralCompatibilityError(expected, real);
			}
		}
		
		return error;
	}
}

void printSetError(String varType, String exprType, Token t):
{}
{
	//Java code
{
	boolean error = checkCompatibilityError(varType, exprType);
	
	if(error){
		System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+exprType+" nao pode ser convertido para tipo "+varType);
	}
}
}

//<Statement> = [“read” <Variable> 
	//| “set” <Variable> “=” <Expression> 
	//| “write” <Variable>
	//| “if” <Condition> “then” <Statements> <ElseClause>
	//| “while” <Condition> “do” <Statements>  “endwhile”
	//| “until” <Condition> "do" <Statements> “enduntil”
	//| “call” <IDENTIFIER> <ArgList> ]
void Statement():
{
	Token t;
	int nparams;
	Symbol o = null;
	String varType, exprType, condType; 
}
{
	(t = <READ> varType = Variable(false, o) {printReadWriteError(varType, t);}/*Java code*/|
	t = <SET> varType = Variable(false, o) <EQUAL> exprType = Expression() {printSetError(varType, exprType, t);} /*Java code*/|
	t = <WRITE> varType = Variable(false, o) {printReadWriteError(varType, t);}/*Java code*/|
	t = <IF> condType = Condition() <THEN> Statements() ElseClause() {printConditionError(condType, t);} /*Java code*/|
	t = <WHILE> condType = Condition() <DO> Statements() <ENDWHILE> {printConditionError(condType, t);} /*Java code*/|
	t = <UNTIL> condType = Condition() <DO> Statements() <ENDUNTIL> {printConditionError(condType, t);} /*Java code*/|
	<CALL> t = <IDENTIFIER> nparams = ArgList(t)
	//Java code
	{
		Symbol s = st.search(t.image.toString());
		if(s == null){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tProcedimento "+t.image.toString()+" nao foi declarado.");
		}else if(!s.getTypeName().equals("PROCEDURE")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao eh um procedimento.");
		}else if(s.getType().get("NPARAMS") == null || !s.getType().get("NPARAMS").equals(nparams)){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para o procedimento "+t.image.toString()+" eh diferente do esperado.");
		}
	}
	)?
}
	
//<ElseClause> = [“else” <Statements>] “endif” 
void ElseClause():
{}
{
	(<ELSE> Statements())? <ENDIF>
}

void printReturnError(String returned, String expected, Token t):
{}
{
	//Java code
	{
	boolean error = checkCompatibilityError(expected, returned);
	
	if(error){
		System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.endColumn+".\n\tTipo "+returned+" nao pode ser convertido para tipo "+expected);
	}
}

}

//tiramos o ; como parte da resolução da ambiguidade com statement
//<ReturnStatement> = “;” “return” “(” <Condition> “)”
void ReturnStatement(String returnType):
{
	String returnedType;
	Token t;
}
{
	<RETURN>t =<LPAR>returnedType = Condition()<RPAR>
	//Java code
	{	printReturnError(returnedType, returnType, t);	}
}

//<ArgList> = [“(” <Arguments> “)” ]
int ArgList(Token t):
{
	int nparams = 0;
}
{
	(<LPAR>nparams = Arguments(t)<RPAR>)?
	{
		return nparams;
	}
}

//usado para resolver ambiguidade entre variable e chamada de funcao
//<ArgListSpecial> = “(” <Arguments> “)” 
int ArgListSpecial(Token t):
{
	int nparams = 0;
}
{
	<LPAR>nparams = Arguments(t)<RPAR>
	//Java code
	{
		return nparams;
	}
}

void printParamError(Token t, int paramIndex, String type):
{}
{
	//Java code
	{
		Symbol subprogram = st.search(t.image.toString());
		if(subprogram != null && subprogram.getType() != null){
		ArrayList<Symbol> params = (ArrayList<Symbol>) subprogram.getType().get("PARAMS");
		if(params != null && paramIndex < params.size() && params.get(paramIndex).getType() != null){
			Type p = params.get(paramIndex).getType();	
			if(p.get("TCLASS").equals("REFERENCE")){
				if(p.get("ELEMTYPE") != null && !((Symbol)p.get("ELEMTYPE")).getId().equals(type)){
					System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tParametro "+(paramIndex+1)+" invalido.\n\tEsperado: "+((Symbol)p.get("ELEMTYPE")).getId()+"\n\tEncontrado: "+type);
}
}else{
	if(p.get("ELEMTYPE") != null && checkCompatibilityError(((Symbol)p.get("ELEMTYPE")).getId(), type)){
		System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tParametro "+(paramIndex+1)+" invalido.\n\tTipo "+type+" nao pode ser convertido para tipo "+((Symbol)p.get("ELEMTYPE")).getId());
}
}
}
}
}
}

//<Arguments> = <Argument> {“,” <Argument>}
int Arguments(Token t):
{
	int nparams = 0;
	String type;
}
{
	type = Argument()
	{printParamError(t, nparams, type); nparams++;}//Java code
	(
		<COMMA> type = Argument() { printParamError(t, nparams, type); nparams++;}//Java code
	)*
	//Java code
	{
		return nparams;
	}
}

//<Condition> = <CompoundCondition> {“\” <CompoundCondition>}
String Condition():
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = CompoundCondition() 
	(
		t = <OR> operand2 = CompoundCondition()
		
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
		}
	)*
	
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger)
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

//<CompoundCondition> =<SimpleCondition> {“&” <SimpleCondition>}
String CompoundCondition():
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = SimpleCondition() 
	(
		t = <AND> operand2 = SimpleCondition()
		
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
		}
	)*
	
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger)
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

//<SimpleCondition> = <Expression> [<RelOp> <Expression>] 
String SimpleCondition():
{
	String operand1;
	String operand2 = null;
	Token t = null;
}
{
	operand1 = Expression()( t = RelOp() operand2 = Expression())?
	//Java code
	{
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t) 
					|| printArithmeticOrRelationalOperandError(operand2, t))
			return null;
		else if(!operand1.equals("INTEGER") || !operand2.equals("INTEGER"))
			return "REAL";
		else
			return "INTEGER";
	}
}

//<Expression> =  <Term> {<AddOp> <Term>} 
String Expression():
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = Term() 
	(
		t = AddOp() operand2 = Term()
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
		}
	)*
	
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger)
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

//<Term> =  <Unary> {<MultiOP> <Unary>}
String Term():
{
	String operand1;
	String operand2;
	Token t = null;
	boolean allInteger = true;
	boolean hasError = false;
}
{
	operand1 = Unary() 
	(
		t = MultOp() operand2 = Unary()
		//Java code
		{
			if(printArithmeticOrRelationalOperandError(operand2, t)){
				hasError = true;
			}else if(!operand2.equals("INTEGER")){
				allInteger = false;
			}
		}
	)*
	//Java code
	{
		if(operand1!= null && !operand1.equals("INTEGER"))
			allInteger = false;
		if(t == null)
			return operand1;
		else if(printArithmeticOrRelationalOperandError(operand1, t))
			return null;
		else if(!hasError && allInteger && !t.image.toString().equals("/"))
			return "INTEGER";
		else if(!hasError)
			return "REAL";
		else
			return null;
	}
}

boolean printArithmeticOrRelationalOperandError(String varType, Token t):
{}
{
	/*Java code*/
	{
		if(varType == null)
			varType = "_NULO_";
		if((!varType.equals("INTEGER") && !varType.equals("REAL"))){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para operador aritmetico.\n\tEsperado: INTEGER ou REAL\n\tEncontrado: "+varType);
			return true;
		}
		return false;
	}
}

//<Unary> = {(“+” | ”-”)} <Factor>
String Unary():
{
	Token t = null;
	String typeName = null;
}
{
	(t = <PLUS>| t = <MINUS>)* typeName = Factor() 
	//Java code
	{
		if(t != null)
			if(printArithmeticOrRelationalOperandError(typeName, t))
				return null;
		return typeName;
	}
}

boolean printLogicOperandError(String varType, Token t):
{}
{
	/*Java code*/
	{
		if(varType == null)
			varType = "_NULO_";
		if(!varType.equals("INTEGER")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+". Tipo invalido para operador logico.\n\tEsperado: INTEGER\n\tEncontrado: "+varType);
			return true;
		}
		return false;
	}
}

//tambem modificado para remover ambiguidade entre variable e chamada de funcao
//<Factor> = <Identifier> <ArgListSpecial> | <NumericLiteral> | <StringLiteral> | “~”<Factor> | “(” <Condition> “)” | <Variable>
String Factor():
{
	Token t;
	int nparams = 0;
	Symbol o = null;
	String typeName = null;
	Symbol type = null;
	Token aux;
}
{
	(
		LOOKAHEAD(2) t = <IDENTIFIER> nparams = ArgListSpecial(t) 
		//Java code
		{
			Symbol s = st.search(t.image.toString());
			if(s == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tFuncao "+t.image.toString()+" nao foi declarada.");
			}else if(!s.getTypeName().equals("FUNCTION") && nparams > 0){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao eh uma funcao.");
			}else if(s.getTypeName().equals("FUNCTION") && !s.getType().get("NPARAMS").equals(nparams)){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
			}else{
				type = (Symbol)s.getType().get("RTYPE");
				typeName = type.getId();
			}
		}
		|
		<FLOAT> {typeName = "REAL";}/*Java code*/|
		<INT>	{typeName = "INTEGER";}/*Java code*/|
		<STRING_LITERAL> {typeName = "STRING";}/*Java code*/|
		aux = <NOT> typeName = Factor() 
		/*Java code*/
		{
			if(printLogicOperandError(typeName, aux))
				return null;
		}
		
		|
		<LPAR>typeName = Condition() <RPAR> |
		typeName = Variable(false, o)
	)
	{return typeName;}
}

//<Variable> = <Identifier> [“[” <Expression> “]”]{“.”<Variable>}
String Variable(boolean recursion, Symbol field):
{
	Token t;
	Symbol type = null;
	String typeName = null;
	boolean hasIndex;
}
{
	{hasIndex = false;}//Java code
	t = <IDENTIFIER> (<LSQ_BRACK>Expression()<RSQ_BRACK>{hasIndex = true;}/*Java code*/)?
	//Java code
	{	
		if(!recursion){//trata identificador inicial
			Symbol s = st.search(t.image.toString());
			field = s;
			
			if(s == null || s.getType() == null){
				field = null;
			}else{
				field = (Symbol) s.getType().get("ELEMTYPE");//s eh do tipo Variable
				type = field;
			}

			while(field != null && (field.getTypeName().equals("TYPE") 
					|| (field.getTypeName().equals("ARRAY") && hasIndex))){
				field = (Symbol) field.getType().get("ELEMTYPE");
			}
			
			//System.out.println(s.getTypeName());
			if(s == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao foi declarado.");
			}else if(!s.getTypeName().equals("VARIABLE") && !s.getTypeName().equals("PARAM") && !s.getTypeName().equals("FUNCTION")){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao pode ser usado nesse contexto.\n\tEsperado:\n\tFuncao, parametro ou variavel.");
			}else if(s.getTypeName().equals("FUNCTION") && !s.getType().get("NPARAMS").equals(0)){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
			}
		}else{//trata campos
			if(field == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tImpossivel acessar o campo "+t.image.toString()+" porque um ou mais campos anteriores nao foram declarados corretamente.");
			}else if(field.getTypeName().equals("ARRAY")){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tImpossivel acessar o campo "+t.image.toString()+" a partir de um array.");
			}else if(!field.getTypeName().equals("RECORD") || field.getType().get(t.image.toString()) == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tCampo "+t.image.toString()+" nao foi declarado.");
				field = null;
			}else{
				field = (Symbol) field.getType().get(t.image.toString());
				type = field;
				while(field != null && (field.getTypeName().equals("TYPE") 
										|| (field.getTypeName().equals("ARRAY") && hasIndex))){
					field = (Symbol) field.getType().get("ELEMTYPE");
				}
			}
		}
	}
	
	(LOOKAHEAD(2)<DOT>typeName = Variable(true, field))*
	{
		if(typeName == null){
			if(type == null || type.getType() == null)
				typeName = "_NULO_";
			else{
				typeName = type.getTypeName();
				if(typeName.equals("TYPE") && hasIndex){
					type = (Symbol)type.getType().get("ELEMTYPE");
					typeName = type.getTypeName();
				}
				
				if(typeName.equals("FUNCTION"))
					type = ((Symbol)type.getType().get("RTYPE"));
				else if(typeName.equals("ARRAY") && hasIndex){
					type = ((Symbol)type.getType().get("ELEMTYPE"));
				}
				else if(typeName.equals("VARIABLE"))
					type = ((Symbol)type.getType().get("ELEMTYPE"));
				
				typeName = type.getId();
			}
			//System.out.println("line: "+t.beginLine+", tipo: "+typeName);			
		}
		return typeName;
	}
}

//<RelOp> = “=” | “!” | “>” | “<” | “<=” | “>=”
Token RelOp():
{
	Token t;
}
{
	(t = <EQUAL> | t = <DIFF> | LOOKAHEAD(2) t = <GTE> | LOOKAHEAD(2)t = <LTE> | t = <GT> | t = <LT>)
	
	{return t;}//Java code
}

//<AddOp> = “+” | “-”
Token AddOp():
{
	Token t;
}
{
	(t = <PLUS> | t = <MINUS>)
	{return t;}//Java code
}

//<MultOp> = “*” | “/”
Token MultOp():
{
	Token t;
}
{
	(t = <MUL> | t = <DIV>)
	{return t;}//Java code
}

//<Argument> = <Condition>
String Argument():
{String typeName;}
{
	typeName = Condition() {return typeName;}//Java code
}

