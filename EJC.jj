options{IGNORE_CASE = true;/*DEBUG_PARSER = true;*/}
/*options{DEBUG_PARSER = true;}*/

PARSER_BEGIN(EJC)
import java.io.*;
import tadsemantico.*;

public class EJC{
	public final static SymbolTable st = new SymbolTable();
	public static int array_counter = 0;
	public static int record_counter = 0;
	public static final int MAX_ID_LENGTH = 128;
	public static final int MAX_STR_LENGTH = 256;
	public static final int MAX_NUM_SIZE = 9;
	
    public static void main(String[] args) throws ParseException, TokenMgrError{
        EJC EJC = new EJC(System.in);
        try{
            EJC.start();
            System.out.println("Sucesso!");
        }catch (Exception e) {
            //System.out.println("Erro!\n" + e.toString());
			e.printStackTrace();
        }
    }
}

PARSER_END(EJC)

SKIP : {
	 " "
	|  "\t"
	|  "\n"
	|  "\r"
	|  "\r\n"
	|  <"{" (~["{", "}"])* "}">
}

/*Operadores*/
TOKEN:
{
    <EOL: "\\n" | "\\r" | "\\r\\n" > |
    <PLUS: "+"> |
    <MINUS: "-"> |
    <DIV: "/"> |
    <MUL: "*"> |
	<OR: "\\"> |
	<AND: "&"> |
	<NOT: "~"> |
	<GT: ">"> |
	<LT: "<"> |
	<GTE: ">="> |
	<LTE: "<="> |
	<EQUAL: "="> |
	<DIFF: "!"> 
}


/*Separadores e Agrupadores*/
TOKEN:
{
  <LPAR: "(">
 | <RPAR: ")">
|	<SEMICOLON: ";">
|	<COMMA: ",">
//|	<QUOT: "\""> 
|	<LSQ_BRACK: "[">
|	<RSQ_BRACK: "]">
|	<DOT: "."> 
}

/*Palavras reservadas e funcoes nativas*/
TOKEN:
{
	<ARRAY: "array">
	| 	<BEGIN: "begin">
	| 	<CALL: "call">
	|	<DO: "do">
	|	<ELSE: "else">
	| 	<END: "end">
	|	<ENDIF: "endif">
	| 	<ENDUNTIL: "enduntil">
	| 	<ENDWHILE: "endwhile">
	| 	<FUNCTION: "function">
	| 	<IF: "if">
	| 	<INTEGER: "integer">
	| 	<PARAMETERS: "parameters">
	| 	<PROCEDURE: "procedure">
	| 	<PROGRAM: "program">
	| 	<READ: "read">
	| 	<REAL: "real">
	| 	<RECORD: "record">
	| 	<RETURN: "return">
	| 	<RETURNS: "returns">
	| 	<SET: "set">
	| 	<STRING: "string">
	| 	<THEN: "then">
	| 	<TYPES: "types">
	| 	<UNTIL: "until">
	| 	<VAR: "var">
	| 	<VARIABLES: "variables">
	|	<WHILE: "while">
	| 	<WRITE: "write">
}

/*Numeros, palavras e identificadores*/
TOKEN:
{
	<#DIGIT: ["0"-"9"] > |
	<#LETTER: "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p"| "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A"| "B"| "C"| "D"| "E"| "F"| "G"| "H"| "I"| "J"| "K"| "L"| "M"| "N"| "O"| "P"| "Q"| "R"| "S"| "T"| "U"| "V"| "W"| "X"| "Y"| "Z"> |
	<#SYMBOL: " " | "!" | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | "\\" | ":" | ";" | "<" | "=" | ">"  | "[" | "]" | "^" | "{" | "|" | "}"> | 
		
	<#DIGITS: (<DIGIT>)*> |
	<#FORCE_DIGITS: <DIGIT>(<DIGIT>)*> |
	//<NUMERIC_LITERAL: <DIGITS> "." <FORCE_DIGITS> | <FORCE_DIGITS>"."<DIGITS>| <FORCE_DIGITS>> |
	<FLOAT: <DIGITS> "." <FORCE_DIGITS> | <FORCE_DIGITS>"."<DIGITS>> 
	//Java code
	{ 
		String[] strs = image.toString().split("\\.");
		
		if(strs[0].length() > EJC.MAX_NUM_SIZE || strs[1].length() > EJC.MAX_NUM_SIZE){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de digitos excedido.");
		}
	}|
	<INT: <FORCE_DIGITS>> 
	//Java code
	{ 
		String str = image.toString();
		if(str.length() > EJC.MAX_NUM_SIZE){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de digitos excedido.");
		}
	}|
	
	<#CHARACTER: <LETTER> | <DIGIT>> |
	<IDENTIFIER: <LETTER>(<CHARACTER>)*> 
	//Java code
	{ 
		str = image.toString();
		if(str.length() > EJC.MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tTamanho maximo para identificador excedido.");
		}
	}|
	
	<#ANY_CHARACTER: <LETTER> | <DIGIT> | <SYMBOL>> |
	<STRING_LITERAL: "\""(<ANY_CHARACTER>)*"\"">
	//Java code
	{ 
		str = image.toString();
		if(str.length() > EJC.MAX_STR_LENGTH){
			System.out.println("Erro semantico na linha "+input_stream.getBeginLine()+", coluna "+input_stream.getBeginColumn()+".\n\tLimite do numero de caracteres excedido.");
		}
	}
}

void start():
{}
{
	Program()
}

//<Program> = <Header> <DeclSec> <Block>"."
void Program():
{Token t;}
{
	Header() DeclSec() Block()t=<DOT>
	//Java code
	{
		st.removeLevel();
	}
}

//<Header> = “program” “identifier” “;”
void Header():
{}
{
	<PROGRAM> <IDENTIFIER> <SEMICOLON>
}

//<Block> = “begin” <Statements> “end”
void Block():
{}
{
	<BEGIN> Statements() <END>
}

//<DeclSec> = <TypeDeclSec> <VarDeclSec> <SubprogramDecls> 
void DeclSec():
{}
{
	TypeDeclSec() VarDeclSec() SubProgramDecls()
}

//<TypeDeclSec> = [“types” <TypeDecls>]
void TypeDeclSec():
{}
{
	(<TYPES> TypeDecls())?
}

//<TypeDecls> = <TypeDecl> {<TypeDecl>}
void TypeDecls():
{}
{
	TypeDecl()(TypeDecl())*
}

//<TypeDecl> = “identifier” <TypeSpecification>
void TypeDecl():
{
	Token t;
	Boolean correctDefinition;
}
{
	t = <IDENTIFIER>
	correctDefinition = TypeSpecification(t)
	//Java code
	{
		if(!correctDefinition || t.image.toString().length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na declaracao do tipo "+t.image.toString()+".");
		}
	}
}

//<TypeSpecification> = <ArraySpecification> | <RecordSpecification>
boolean TypeSpecification(Token typeToken):
{
	Boolean isCorrect;
}
{
	isCorrect = ArraySpecification(typeToken) {return isCorrect;} //Java code
	| isCorrect = RecordSpecification(typeToken) {return isCorrect;} //Java code
}

//<ArraySpecification> = “array” <DataType> “[” <NumericLiteral> ”]” ";"
boolean ArraySpecification(Token typeToken):
{
	Token t;
	Boolean isCorrect;
}
{
	<ARRAY> t = DataType() 
	//Java code
	{
            String arrayName = "ARRAY"+array_counter;    
			st.addSymbol(arrayName, "ARRAY");
			Symbol s = st.search(t.image.toString());
			if(s == null || (!s.getTypeName().equals("TYPE") && !s.getTypeName().equals("REAL") && !s.getTypeName().equals("STRING") && !s.getTypeName().equals("INTEGER"))){
				//System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+t.image.toString()+" nao definido.");
				isCorrect = false;
			}else{ 
				st.search(arrayName).getType().set("ELEMTYPE", s);
				isCorrect = true;
			}
            array_counter++;
		
	}
	<LSQ_BRACK> t = <INT>
	//Java code
	{       //only if the array exists (check the code above!)
		int size = 0;
		try{
			size = Integer.parseInt(t.image.toString());
		}catch(Exception e){
			isCorrect = false;
		}
		st.search(arrayName).getType().set("size", size);
		boolean result = st.isSet(typeToken.image.toString());
		if(isCorrect && result){
			System.out.println("Erro semantico na linha "+typeToken.beginLine+", coluna "+typeToken.beginColumn+".\n\tTipo "+typeToken.image.toString()+" ja foi definido nesse contexto.");
		}else if(t.image.toString().length() > MAX_NUM_SIZE){
			isCorrect = false;
		}else if(isCorrect && typeToken.image.toString().length() <= MAX_ID_LENGTH){
			st.addSymbol(typeToken.image.toString(), "TYPE");
			st.search(typeToken.image.toString()).getType().set("ELEMTYPE", st.search(arrayName));
		}
	}
	<RSQ_BRACK><SEMICOLON>
	//Java code
	{return isCorrect;}
}


//<RecordSpecification> = “record” <VarDecls> “end” “;”
boolean RecordSpecification(Token typeToken):
{
	Boolean isCorrect;
}
{
	<RECORD> 
	//Java code
	{
			String typeName = typeToken.image.toString();
            String recordName = "RECORD"+record_counter;    
			st.addSymbol(recordName, "RECORD");
	}
	isCorrect = VarDecls(true) 
	//Java code
	{
			record_counter++;
			boolean result = st.isSet(typeName);
			if(isCorrect && result){
				System.out.println("Erro semantico na linha "+typeToken.beginLine+", coluna "+typeToken.beginColumn+".\n\tTipo "+typeToken.image.toString()+" ja foi definido nesse contexto.");
			}else if(isCorrect && typeName.length() <= MAX_ID_LENGTH){
				st.addSymbol(typeName, "TYPE");
				st.search(typeName).getType().set("ELEMTYPE", st.search(recordName));
			}
	}
	<END><SEMICOLON>
	//Java code
	{return isCorrect;}
}

//<VarDeclSec> = [“variables” <VarDecls>]
void VarDeclSec():
{}
{
	(<VARIABLES> VarDecls(false))?
}

//<VarDecls> = <VarDecl> {<VarDecl>}
boolean VarDecls(boolean comingFromRecordSpec):
{
	Boolean isCorrect = true;
	Boolean temp = false;
}
{
	temp = VarDecl(comingFromRecordSpec)
	//Java code
	{isCorrect = isCorrect && temp;}
	(
		temp = VarDecl(comingFromRecordSpec)
		//Java code
		{isCorrect = isCorrect && temp;}
	
	)*
	
	//Java code
	{return isCorrect;}
}

//<VarDecl> = <DataType> <IdList> “;”
boolean VarDecl(boolean comingFromRecordSpec):
{
	Token t;
	Boolean isCorrect;
}
{
	t = DataType() 
	isCorrect = IdList(t, comingFromRecordSpec) <SEMICOLON>
	//Java code
	{return isCorrect;}
}

//<DataType> = “real” | “integer” | <Identifier> | <String>
Token DataType():
{
	Token t;
}
{
	(t = <REAL> | t = <INTEGER> | 
	t = <IDENTIFIER> 
	//Java code
	{
		Symbol dt = st.search(t.image.toString());
		if(dt == null || (dt != null && !dt.getTypeName().equals("TYPE"))){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tTipo "+t.image.toString()+" nao esta definido.");
		}
	}
	| t = <STRING>)
	{return t;}
}

boolean addRecordField(Token datatype, Token identifier, boolean comingFromRecordSpec):
{
	Boolean isCorrect = true;
}
{	//Java code
	{
		if(comingFromRecordSpec){
			if(st.search(datatype.image.toString()) != null){//certifica-se que tipo eh valido, mas nao precisa imprimir nada caso nao seja
				boolean result = st.search("RECORD"+record_counter).getType().set(identifier.image.toString(), st.search(datatype.image.toString()));
				if(!result){
					System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tCampo "+identifier.image.toString()+" duplicado.");
					isCorrect = false;
				}			
			}else{
				isCorrect = false;
			}
		}else if(st.isSet(identifier.image.toString())){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tIdentificador "+identifier.image.toString()+" duplicado.");
		}else if(identifier.image.toString().length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tErro na definicao de "+identifier.image.toString()+".");
		}else{
			st.addSymbol(identifier.image.toString(), "VARIABLE");
			st.search(identifier.image.toString()).getType().set("ELEMTYPE", st.search(datatype.image.toString()));
		}
		return isCorrect;
	}
}

//<IdList> = <Identifier> {“,” <Identifier>}
boolean IdList(Token datatype, boolean comingFromRecordSpec):
{
	Token t;
	Boolean isCorrect = true;
	Boolean temp = false;
}
{
	t = <IDENTIFIER>
	//Java code
	{
		temp = addRecordField(datatype, t, comingFromRecordSpec);
		isCorrect = isCorrect && temp;
	}
	(
		<COMMA>
		t = <IDENTIFIER>
		//Java code
		{
			temp = addRecordField(datatype, t, comingFromRecordSpec);
			isCorrect = isCorrect && temp;
		}
	)*
	//Java code
	{return isCorrect;}
}

//<SubProgramDecls> = {<SubProgramDecl>}
void SubProgramDecls():
{}
{
	(SubProgramDecl())*
}

//<SubProgramDecl> = <ProcDecl> | <FunctionDecl>
void SubProgramDecl():
{}
{
	(ProcDecl() | FunctionDecl())
	//Java code
	{
		st.removeLevel();
	}
}

//<ProcDecl> = <ProcHeader> <SubProgramDeclSec> <Block> “;”
void ProcDecl():
{
	String procName;
}
{
	procName = ProcHeader() SubProgramDeclSec(procName) Block() <SEMICOLON>
}

//<ProcHeader> = “procedure” <Identifier> “;”
String ProcHeader():
{
	Token t;
}
{
	<PROCEDURE> t = <IDENTIFIER> <SEMICOLON>
	//Java code
	{
		String procName = t.image.toString();
		if(procName.length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na definicao do procedimento "+t.image.toString()+".");
		}else if(!st.addSymbol(procName, "PROCEDURE")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tIdentificador "+t.image.toString()+" ja foi definido nesse contexto.");
		}
		st.addLevel();
		return procName;
	}
}

//<SubProgramDeclSec> = <ParamDeclSec> <DeclSec>
void SubProgramDeclSec(String subProgramName):
{ 
	int nparams = 0;
}
{
	nparams = ParamDeclSec()
	//Java code
	{
		st.search(st.getCurrentLevel()-1, subProgramName).getType().set("nparams", nparams);
	}
	DeclSec()
}

//<ParamDeclSec> = [“parameters” <ParamDecls>]
int ParamDeclSec():
{
	int nparams = 0;
}
{
	(<PARAMETERS> nparams = ParamDecls())?
	//Java code
	{
		return nparams;
	}
}

//<ParamDecls> = {<ParamDecl>}
int ParamDecls():
{
	int nparams = 0;
}
{
	(nparams = ParamDecl(nparams))*
	//Java code
	{
		return nparams;
	}
}

//<ParamDecl> =["var"] <DataType> <Identifier> ";"
int ParamDecl(int nparams):
{
	Token datatype;
	Token identifier;
	String tClass = "VALUE";
}
{
	(
		<VAR>
		//Java code
		{
				tClass = "REFERENCE";
		}
	)? 
	datatype = DataType() identifier = <IDENTIFIER> <SEMICOLON>
	//Java code
	{
		if(identifier.image.toString().length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tErro na definicao do parametro "+identifier.image.toString()+".");
		}else if(!st.addSymbol(identifier.image.toString(), "PARAM")){
			System.out.println("Erro semantico na linha "+identifier.beginLine+", coluna "+identifier.beginColumn+".\n\tIdentificador "+identifier.image.toString()+" ja foi definido nesse contexto.");
		}else{
			Type t = st.search(identifier.image.toString()).getType();
			t.set("ELEMTYPE", st.search(datatype.image.toString()));
			t.set("TCLASS", tClass);
		}
		return nparams+1;
	}
}

//<FunctionDecl> = <FunctionHeader> <SubProgramDeclSec> <FunctionBlock> “;”
void FunctionDecl():
{
	String funcName;
}
{
	funcName = FunctionHeader() SubProgramDeclSec(funcName) FunctionBlock() <SEMICOLON>
}

//<FunctionHeader> = “function” <Identifier> “returns” <DataType>;
String FunctionHeader():
{
	Token t;
	Token returnType;
}
{
	<FUNCTION> t = <IDENTIFIER> <RETURNS> returnType = DataType() <SEMICOLON>
	//Java code
	{
		String funcName = t.image.toString();
		if(funcName.length() > MAX_ID_LENGTH){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tErro na definicao da funcao "+t.image.toString()+".");	
		}else if(!st.addSymbol(funcName, "FUNCTION")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tIdentificador "+t.image.toString()+" ja foi definido nesse contexto.");
		}else{
			st.search(funcName).getType().set("RTYPE", st.search(returnType.image.toString()));
		}
		st.addLevel();
		return funcName;
	}
}

//modificado pra resolver ambiguidade
//<FunctionBlock> = “begin” <SpecialStatements> “end”
void FunctionBlock():
{}
{
	<BEGIN> SpecialStatements() <END>
}

//<Statements> = <Statement> { “;”<Statement>}
void Statements():
{}
{
	Statement()(<SEMICOLON>Statement())*
}

//criado para resolver a ambiguidade com ReturnStatement
//<SpecialStatements> = <Statement>“;”{<Statement>“;”}<ReturnStatement>
void SpecialStatements():
{}
{
	(LOOKAHEAD(2)Statement()<SEMICOLON>)+ReturnStatement()
}

//<Statement> = [“read” <Variable> 
	//| “set” <Variable> “=” <Expression> 
	//| “write” <Variable>
	//| “if” <Condition> “then” <Statements> <ElseClause>
	//| “while” <Condition> “do” <Statements>  “endwhile”
	//| “until” <Condition> "do" <Statements> “enduntil”
	//| “call” <IDENTIFIER> <ArgList> ]
void Statement():
{
	Token t;
	int nparams;
	Symbol o = null;
}
{
	(<READ> Variable(false, o) |
	<SET> Variable(false, o) <EQUAL> Expression() |
	<WRITE> Variable(false, o) |
	<IF> Condition() <THEN> Statements() ElseClause() |
	<WHILE> Condition() <DO> Statements() <ENDWHILE> |
	<UNTIL> Condition() <DO> Statements() <ENDUNTIL> |
	<CALL> t = <IDENTIFIER> nparams = ArgList()
	//Java code
	{
		Symbol s = st.search(t.image.toString());
		if(s == null){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tProcedimento "+t.image.toString()+" nao foi definido.");
		}else if(!s.getTypeName().equals("PROCEDURE")){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao eh um procedimento.");
		}else if(s.getType().get("NPARAMS") == null || !s.getType().get("NPARAMS").equals(nparams)){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para o procedimento "+t.image.toString()+" eh diferente do esperado.");
		}
	}
	)?
}
	
//<ElseClause> = [“else” <Statements>] “endif” 
void ElseClause():
{}
{
	(<ELSE> Statements())? <ENDIF>
}

//tiramos o ; como parte da resolução da ambiguidade com statement
//<ReturnStatement> = “;” “return” “(” <Condition> “)”
void ReturnStatement():
{}
{
	<RETURN><LPAR>Condition()<RPAR>
}

//<ArgList> = [“(” <Arguments> “)” ]
int ArgList():
{
	int nparams = 0;
}
{
	(<LPAR>nparams = Arguments()<RPAR>)?
	{
		return nparams;
	}
}

//usado para resolver ambiguidade entre variable e chamada de funcao
//<ArgListSpecial> = “(” <Arguments> “)” 
int ArgListSpecial():
{
	int nparams = 0;
}
{
	<LPAR>nparams = Arguments()<RPAR>
	//Java code
	{
		return nparams;
	}
}

//<Arguments> = <Argument> {“,” <Argument>}
int Arguments():
{
	int nparams = 0;
}
{
	Argument()
	{nparams++;}//Java code
	(
		<COMMA> Argument() {nparams++;}//Java code
	)*
	//Java code
	{
		return nparams;
	}
}

//<Condition> = <CompoundCondition> {“\” <CompoundCondition>}
void Condition():
{}
{
	CompoundCondition() (<OR> CompoundCondition())*
}

//<CompoundCondition> =<SimpleCondition> {“&” <SimpleCondition>}
void CompoundCondition():
{}
{
	SimpleCondition() (<AND> SimpleCondition())*
}

//<SimpleCondition> = <Expression> [<RelOp> <Expression>] 
void SimpleCondition():
{}
{
	Expression() (RelOp() Expression())?
}

//<Expression> =  <Term> {<AddOp> <Term>} 
void Expression():
{}
{
	Term() (AddOp() Term())*
}

//<Term> =  <Unary> {<MultiOP> <Unary>}
void Term():
{}
{
	Unary() (MultOp() Unary())*
}

//<Unary> = {(“+” | ”-”)} <Factor>
void Unary():
{}
{
	(<PLUS>|<MINUS>)*Factor()
}

//tambem modificado para remover ambiguidade entre variable e chamada de funcao
//<Factor> = <Identifier> <ArgListSpecial> | <NumericLiteral> | <StringLiteral> | “~”<Factor> | “(” <Condition> “)” | <Variable>
void Factor():
{
	Token t;
	int nparams = 0;
	Symbol o = null;
}
{
	LOOKAHEAD(2) t = <IDENTIFIER> nparams = ArgListSpecial() 
	//Java code
	{
		Symbol s = st.search(t.image.toString());
		if(s == null){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tFuncao "+t.image.toString()+" nao foi definida.");
		}else if(!s.getTypeName().equals("FUNCTION") && nparams > 0){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao eh uma funcao.");
		}else if(s.getTypeName().equals("FUNCTION") && !s.getType().get("NPARAMS").equals(nparams)){
			System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
		}
	}
	|
	<FLOAT> |
	<INT>	|
	<STRING_LITERAL> |
	<NOT>Factor() |
	<LPAR>Condition() <RPAR> |
	Variable(false, o)
}

//<Variable> = <Identifier> [“[” <Expression> “]”]{“.”<Variable>}
void Variable(boolean recursion, Symbol field):
{
	Token t;
}
{
	t = <IDENTIFIER>
	//Java code
	{
		if(!recursion){//trata identificador inicial
			Symbol s = st.search(t.image.toString());
			field = s;
			
			if(s == null || s.getType() == null){
				field = null;
			}else{
				field = (Symbol) s.getType().get("ELEMTYPE");//s eh do tipo Variable
			}

			while(field != null && (field.getTypeName().equals("TYPE") || field.getTypeName().equals("ARRAY"))){
				field = (Symbol) field.getType().get("ELEMTYPE");
			}
			
			if(s == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao foi definido.");
			}else if(!s.getTypeName().equals("VARIABLE") && !s.getTypeName().equals("PARAM") && !s.getTypeName().equals("FUNCTION")){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\t"+t.image.toString()+" nao pode ser usado nesse contexto.\n\tEsperado:\n\tFuncao, parametro ou variavel.");
			}else if(s.getTypeName().equals("FUNCTION") && !s.getType().get("NPARAMS").equals(0)){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
			}
		}else{//trata campos
			if(field == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tImpossivel acessar o campo "+t.image.toString()+" porque um ou mais campos anteriores nao foram definidos corretamente.");
			}else if(!field.getTypeName().equals("RECORD") || field.getType().get(t.image.toString()) == null){
				System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\n\tCampo "+t.image.toString()+" nao foi definido.");
				field = null;
			}else{
				field = (Symbol) field.getType().get(t.image.toString());
					
				while(field != null && (field.getTypeName().equals("TYPE") || field.getTypeName().equals("ARRAY"))){
					field = (Symbol) field.getType().get("ELEMTYPE");
				}
			}
		}
	}
	
	(<LSQ_BRACK>Expression()<RSQ_BRACK>)?(LOOKAHEAD(2)<DOT>Variable(true, field))*
}

//<RelOp> = “=” | “!” | “>” | “<” | “<=” | “>=”
void RelOp():
{}
{
	<EQUAL> | <DIFF> | LOOKAHEAD(2) <GTE> | LOOKAHEAD(2)<LTE> | <GT> | <LT>
}

//<AddOp> = “+” | “-”
void AddOp():
{}
{
	<PLUS> | <MINUS>
}

//<MultOp> = “*” | “/”
void MultOp():
{}
{
	<MUL> | <DIV>
}

//<Argument> = <Condition>
void Argument():
{}
{
	Condition()
}
	
/*void start():
{
	Token t;
}
{
    (
		t = <EOL> {System.out.printf("@(%d,%d)\t<EOL>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <PLUS>   {System.out.printf("@(%d,%d)\t<PLUS>\t-\t%s\n", t.beginLine, t.beginColumn, t);}  | 
		t = <MINUS>  {System.out.printf("@(%d,%d)\t<MINUS>\t-\t%s\n", t.beginLine, t.beginColumn, t);}  | 
		t = <DIV>  {System.out.printf("@(%d,%d)\t<DIV>\t-\t%s\n", t.beginLine, t.beginColumn, t);}  | 
		t = <MUL>  {System.out.printf("@(%d,%d)\t<MUL>\t-\t%s\n", t.beginLine, t.beginColumn, t);}  | 
		t = <OR>  {System.out.printf("@(%d,%d)\t<OR>\t-\t%s\n", t.beginLine, t.beginColumn, t);}  |
		t = <AND>  {System.out.printf("@(%d,%d)\t<AND>\t-\t%s\n", t.beginLine, t.beginColumn, t);}  | 
		t = <NOT>  {System.out.printf("@(%d,%d)\t<NOT>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <GT> {System.out.printf("@(%d,%d)\t<GT>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <LT> {System.out.printf("@(%d,%d)\t<LT>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <GTE> {System.out.printf("@(%d,%d)\t<GTE>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <LTE> {System.out.printf("@(%d,%d)\t<LTE>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <EQUAL> {System.out.printf("@(%d,%d)\t<EQUAL>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <DIFF> {System.out.printf("@(%d,%d)\t<DIFF>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <LPAR> {System.out.printf("@(%d,%d)\t<LPAR>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <RPAR> {System.out.printf("@(%d,%d)\t<RPAR>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <SEMICOLON> {System.out.printf("@(%d,%d)\t<SEMICOLON>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <COMMA> {System.out.printf("@(%d,%d)\t<COMMA>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
	//	t = <QUOT> {System.out.printf("@(%d,%d)\t<QUOT>\t-\t%s\n", t.beginLine, t.beginColumn, t);} | 
		t = <LSQ_BRACK> {System.out.printf("@(%d,%d)\t<LSQ_BRACK>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <RSQ_BRACK> {System.out.printf("@(%d,%d)\t<RSQ_BRACK>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <DOT> {System.out.printf("@(%d,%d)\t<DOT>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <ARRAY>  {System.out.printf("@(%d,%d)\t<ARRAY>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <BEGIN>  {System.out.printf("@(%d,%d)\t<BEGIN>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <CALL>  {System.out.printf("@(%d,%d)\t<CALL>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <DO>  {System.out.printf("@(%d,%d)\t<DO>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <ELSE>  {System.out.printf("@(%d,%d)\t<ELSE>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <END>  {System.out.printf("@(%d,%d)\t<END>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <ENDIF>  {System.out.printf("@(%d,%d)\t<ENDIF>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <ENDUNTIL>  {System.out.printf("@(%d,%d)\t<ENDUNTIL>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <ENDWHILE>  {System.out.printf("@(%d,%d)\t<ENDWHILE>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <FUNCTION>  {System.out.printf("@(%d,%d)\t<FUNCTION>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <IF>  {System.out.printf("@(%d,%d)\t<IF>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <INTEGER>  {System.out.printf("@(%d,%d)\t<INTEGER>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <PARAMETERS>  {System.out.printf("@(%d,%d)\t<PARAMETERS>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <PROCEDURE>  {System.out.printf("@(%d,%d)\t<PROCEDURE>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <PROGRAM>  {System.out.printf("@(%d,%d)\t<PROGRAM>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <READ>  {System.out.printf("@(%d,%d)\t<READ>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <REAL>  {System.out.printf("@(%d,%d)\t<REAL>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <RECORD>  {System.out.printf("@(%d,%d)\t<RECORD>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <RETURN>  {System.out.printf("@(%d,%d)\t<RETURN>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <RETURNS>  {System.out.printf("@(%d,%d)\t<RETURNS>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <SET>  {System.out.printf("@(%d,%d)\t<SET>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <STRING>  {System.out.printf("@(%d,%d)\t<STRING>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <THEN>  {System.out.printf("@(%d,%d)\t<THEN>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <TYPES>  {System.out.printf("@(%d,%d)\t<TYPES>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <UNTIL>  {System.out.printf("@(%d,%d)\t<UNTIL>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <VAR>  {System.out.printf("@(%d,%d)\t<VAR>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <VARIABLES>  {System.out.printf("@(%d,%d)\t<VARIABLES>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <WHILE>  {System.out.printf("@(%d,%d)\t<WHILE>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <WRITE>  {System.out.printf("@(%d,%d)\t<WRITE>\t-\t%s\n", t.beginLine, t.beginColumn, t);}|
		t = <IDENTIFIER> {System.out.printf("@(%d,%d)\t<ID>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		//t = <NUMERIC_LITERAL> {System.out.printf("@(%d,%d)\t<NUM>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <FLOAT> {System.out.printf("@(%d,%d)\t<FLOAT>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <INT> {System.out.printf("@(%d,%d)\t<INT>\t-\t%s\n", t.beginLine, t.beginColumn, t);} |
		t = <STRING_LITERAL> {System.out.printf("@(%d,%d)\t<STRING>\t-\t%s\n", t.beginLine, t.beginColumn, t);}

	)* 
	t = <EOF>
	   {System.out.printf("@(%d,%d)\t<EOF>\t-\t%s\n", t.beginLine, t.beginColumn, t);}
}
*/